In the parse function below, where the comment says check shape, can you fill it in? üç™üç™üç™

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta copyright="Copyright 2024 ¬© Jon DuBois, 4o cookie dough, and o1 honey bun.">
<link rel="icon" href="favicon.png">
<title>Tensor oriented stack programming.</title>
<style>
button {
    margin: 5px;
    padding: 10px;
}
pre {
    white-space: pre;     /* Prevents word wrap */
    font-family: monospace;
    font-size: 10px;      /* Optional: Adjust for readability */
    overflow-x: auto;     /* Adds scrollbar if needed */
    max-width: 100%;      /* Ensures pre doesn't exceed container */
}
</style>
</head>
<body>
<div>
<input type="text" id="programField" placeholder="Enter expression here...">
<button id="parse">Parse</button>
<br>
<button id="pushIndexTensor">Push index tensor</button>
<button id="popTensor">Pop tensor</button>
<button id="pushRandomTensor">Push random tensor</button>
<button id="pushSingleton">Push singleton</button>
<button id="dumpMemory">Dump GPU Memory</button>
</div>
<canvas id="glCanvas" width="64" height="64" style="display: none;"></canvas>
<pre id="output"></pre>
<script>
const maxDim = 4096;
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl2');
const outputElement = document.getElementById('output');

if (!gl) {
    console.error('WebGL 2 not supported');
    document.body.innerHTML = 'WebGL 2 is not supported in your browser.';
}

// Enable the EXT_color_buffer_float extension
const ext = gl.getExtension('EXT_color_buffer_float');
if (!ext) {
    console.error('EXT_color_buffer_float not supported');
    document.body.innerHTML = 'EXT_color_buffer_float is not supported in your browser.';
}

// Stack to hold tensors
let tensorStack = []; // Each tensor is an object {shape: [...], data: Float32Array, texture: WebGLTexture, width, height}

function generateRandomSize(maxDim, maxElements) {
    let shape = [];
    let dims = Math.floor(Math.random() * maxDim) + 1; // Number of dimensions between 1 and maxDim

    let totalElements = 1;
    for (let i = 0; i < dims; i++) {
        let remainingDims = dims - i;
        let maxSize = Math.floor(Math.pow(maxElements / totalElements, 1 / remainingDims));
        if (maxSize <= 1) {
            shape.push(1);
            totalElements *= 1;
        } else {
            let size = Math.floor(Math.random() * maxSize) + 1; 
            shape.push(size);
            totalElements *= size;
        }
    }
    return shape;
}

function generateIndexTensor(size) {
    let totalElements = size.reduce((a, b) => a * b, 1);
    let data = new Float32Array(size.length * totalElements);
    let shape = size.slice(); // Copy of the size array
    shape.push(size.length); // Increase rank by one

    for (let i = 0; i < totalElements; i++) {
        let remainder = i;
        for (let j = size.length - 1; j >= 0; j--) {
            data[i * size.length + j] = remainder % size[j];
            remainder = Math.floor(remainder / size[j]);
        }
    }
    return [shape, data];
}

function generateRandomTensor(shape) {
    let totalElements = shape.reduce((a, b) => a * b, 1);
    let data = new Float32Array(totalElements);

    for (let i = 0; i < totalElements; i++) {
        data[ i ] = Math.random();
    }
    return [shape, data];
}

function createTextureFromData(gl, data) {
    let totalTexels = Math.ceil(data.length / 4); 
    let width = Math.min(totalTexels, maxDim);
    let height = Math.ceil(totalTexels / width);

    // Create a Float32Array with length width * height * 4 (RGBA)
    let textureData = new Float32Array(width * height * 4);
    for (let i = 0; i < data.length; i++) {
        textureData[i] = data[i];
    }

    // Fill the rest of the texture data with zeros if necessary
    for (let i = data.length; i < (width * height * 4); i++) {
        textureData[i] = 0;
    }

    // Create texture
    let texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // Set texture parameters
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    // Allocate texture storage and upload data
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, textureData);

    // Unbind texture
    gl.bindTexture(gl.TEXTURE_2D, null);

    return { texture: texture, width: width, height: height };
}

function pushIndexTensor() {
    let size = generateRandomSize(4, 64);
    let [shape, data] = generateIndexTensor(size);
    let { texture, width, height } = createTextureFromData(gl, data);
    tensorStack.push({
        shape: shape,
        data: data,
        texture: texture,
        width: width,
        height: height
    });
    outputElement.textContent = `Pushed index tensor with shape [${shape.join(', ')}] onto the stack. Stack size: ${tensorStack.length}`;
}

function pushRandomTensor() {
    let size = generateRandomSize(6, 64);
    let [shape, data] = generateRandomTensor(size);
    let { texture, width, height } = createTextureFromData(gl, data);
    tensorStack.push({
        shape: shape,
        data: data,
        texture: texture,
        width: width,
        height: height
    });
    outputElement.textContent = `Pushed random tensor with shape [${shape.join(', ')}] onto the stack. Stack size: ${tensorStack.length}`;
}

function pushSingleton(x) {
    let data = new Float32Array([x]);
    let { texture, width, height } = createTextureFromData(gl, data);
    tensorStack.push({
        shape: [],
        data: data,
        texture: texture,
        width: width,
        height: height
    });
    outputElement.textContent = `Pushed singleton  [${x}] onto the stack. Stack size: ${tensorStack.length}`;
}

function popTensor() {
    if (tensorStack.length > 0) {
        let tensor = tensorStack.pop();
        gl.deleteTexture(tensor.texture);
        outputElement.textContent = `Popped tensor with shape [${tensor.shape.join(', ')}] from the stack. Stack size: ${tensorStack.length}`;
    } else {
        outputElement.textContent = 'Cannot pop: Stack is empty';
    }
}

function formatTensorData(data, shapeArg) {
    let shape = [1, ...shapeArg];
    // Calculate global maximum number length
    const maxNumLength = Math.max(...data.map(num => num.toString().length));
    if (shape.length === 0) { 
        return '[' + data[0] + ']';
    }
    function helper(dimIndex, offset, depth) {
        if (dimIndex === shape.length - 1) {
            // Base case: last dimension
            let elements = [];
            for (let i = 0; i < shape[dimIndex]; i++) {
                let numStr = data[offset + i].toString().padEnd(maxNumLength, ' ');
                elements.push(numStr);
            }
            return elements.join(' ');
        } else {
            // Determine stacking direction based on depth
            let isHorizontal = (depth % 2 === 0);

            // Recursive case
            let blocks = [];
            let size = shape.slice(dimIndex + 1).reduce((a, b) => a * b, 1);
            for (let i = 0; i < shape[dimIndex]; i++) {
                let inner = helper(dimIndex + 1, offset + i * size, depth + 1);
                blocks.push(inner);
            }

            if (isHorizontal) {
                // Stack horizontally with boxes
                let blockLinesArray = blocks.map(block => {
                    let lines = block.split('\n');
                    let maxLineLength = Math.max(...lines.map(line => line.length));
                    let maxLength = Math.max(maxLineLength, maxNumLength);

                    let top = '‚îå' + '‚îÄ'.repeat(maxLength + 2) + '‚îê';
                    let bottom = '‚îî' + '‚îÄ'.repeat(maxLength + 2) + '‚îò';
                    let middle = lines.map(line => '‚îÇ ' + line.padEnd(maxLength) + ' ‚îÇ');
                    return [top, ...middle, bottom];
                });

                // Determine the maximum height among all blocks
                let maxHeight = Math.max(...blockLinesArray.map(blockLines => blockLines.length));

                // Pad blocks to have the same height
                blockLinesArray = blockLinesArray.map(blockLines => {
                    let width = blockLines[0].length;
                    if (blockLines.length < maxHeight) {
                        let emptyLine = ' '.repeat(width);
                        let padding = Array(maxHeight - blockLines.length).fill(emptyLine);
                        blockLines = [...blockLines, ...padding];
                    }
                    return blockLines;
                });

                // Combine blocks line by line
                let combinedLines = [];
                for (let i = 0; i < maxHeight; i++) {
                    let line = blockLinesArray.map(blockLines => blockLines[i]).join(' ');
                    combinedLines.push(line);
                }
                return combinedLines.join('\n');
            } else {
                // Stack vertically with boxes
                let blockLinesArray = blocks.map(block => {
                    let lines = block.split('\n');
                    let maxLineLength = Math.max(...lines.map(line => line.length));
                    let maxLength = Math.max(maxLineLength, maxNumLength);

                    let top = '‚îå' + '‚îÄ'.repeat(maxLength + 2) + '‚îê';
                    let bottom = '‚îî' + '‚îÄ'.repeat(maxLength + 2) + '‚îò';
                    let middle = lines.map(line => '‚îÇ ' + line.padEnd(maxLength) + ' ‚îÇ');
                    return [top, ...middle, bottom];
                });

                // Determine the maximum width among all blocks
                let maxWidth = Math.max(...blockLinesArray.map(blockLines => blockLines[0].length));

                // Pad blocks to have the same width
                blockLinesArray = blockLinesArray.map(blockLines => {
                    return blockLines.map(line => line.padEnd(maxWidth));
                });

                // Combine blocks vertically
                let combinedLines = [];
                blockLinesArray.forEach(blockLines => {
                    combinedLines.push(...blockLines);
                });
                return combinedLines.join('\n');
            }
        }
    }
    return helper(0, 0, 0);
}

function dumpGPUMemory() {
    if (tensorStack.length === 0) {
        outputElement.textContent = 'Stack is empty';
        return;
    }

    let output = '';
    for (let i = 0; i < tensorStack.length; i++) {
        let tensor = tensorStack[i];
        let shape = tensor.shape;
        let totalElements = tensor.data.length;
        let width = tensor.width;
        let height = tensor.height;

        // Create a framebuffer and attach the texture
        let framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tensor.texture, 0);

        // Read pixels
        let pixels = new Float32Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, pixels);

        // Extract the data from the pixels
        let data = [];
        for (let j = 0; j < totalElements; j++) {
            data.push(pixels[j]);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(framebuffer);

        output += `Tensor ${i}:\n`;
        output += `Shape: [${shape.join(' ')}]\n`;
        output += `Data:\n${formatTensorData(data, shape)}\n\n`;
    }

    outputElement.textContent = output;
}

function setProgram(x) {
    document.getElementById('programField').value = x + document.getElementById('programField').value;
}

function tokenize(string) {
    const tokens = [];
    let current = '';
    const operators = new Set(['?', '‚Ü•', 'i']);
    const brackets = new Set(['[', ']', '(', ')']);
    const whitespace = /\s/;
    
    function addToken(type, value) {
        tokens.push({type, value});
    }
    
    for (let i = 0; i < string.length; i++) {
        const char = string[i];
        
        // Skip whitespaces
        if (whitespace.test(char)) {
            continue;
        }

        // Handle numbers (both integers and decimals, with optional minus sign)
        if ((char === '-' && /\d/.test(string[i+1])) || /\d/.test(char)) {
            current += char;
            let decimalAdded = char === '.';

            while (i + 1 < string.length && (/\d/.test(string[i + 1]) || (!decimalAdded && string[i + 1] === '.'))) {
                if (string[i + 1] === '.') {
                    decimalAdded = true;
                }
                current += string[++i];
            }

            addToken('n', parseFloat(current)); // number
            current = '';
            continue;
        }
        
        // Handle functions (?, ‚Ü•, i)
        if (operators.has(char)) {
            addToken('f', char); // function
            continue;
        }
        
        // Handle brackets and parentheses
        if (brackets.has(char)) {
            addToken('b', char); // bracket
            continue;
        }
        
        // Handle invalid characters
        error(`SYNTAX ERROR: Invalid character encountered: ${char}.`);
    }
    
    return tokens;
}

function parse() {
    clearErrors();
    const program = document.getElementById('programField').value;
    const tokens = tokenize(program);

    let index = tokens.length - 1;
    while (index >= 0) {
        const token = tokens[index];
        if (token.type === 'b' && token.value === '[') {
            error("SYNTAX ERROR: Unbalanced square brackets [], unexpected [.");
        }
        else if (token.type === 'b' && token.value === ']') {
            // First search for the matching '['
            let start = index - 1;
            let bracketLevel = 1;
            let rank = 0;
            while (start >= 0) {
                const stoken = tokens[start];
                if (stoken.type === 'b' && stoken.value === '[') {
                    bracketLevel--;
                    if (bracketLevel === 0)
                        break;
                } else if (stoken.type === 'b' && stoken.value === ']') {
                    bracketLevel++;
                } else {
                    if (stoken.type !== 'n') 
                        error("SYNTAX ERROR: Malformed tensor, expected numbers.");
                    else {
                        if (rank === 0)
                            rank = bracketLevel;
                        else if (rank !== bracketLevel)
                            error("SYNTAX ERROR: Malformed tensor, not all numbers are at equal depths.");
                    }
                }
                start--;
            }
            if (start < 0)
                error("SYNTAX ERROR: Unbalanced square brackets [] while searching for [.");

            // *** Check Shape ***
            // Extract the tokens that make up the tensor
            const tensorTokens = tokens.slice(start + 1, index);
            
            // Function to recursively determine the shape
            function determineShape(tokens, start, depth) {
                let shape = [];
                let currentDepth = depth;
                let i = start;
                let localShape = [];

                while (i < tokens.length) {
                    const tok = tokens[i];
                    if (tok.type === 'b' && tok.value === '[') {
                        const [subShape, newIndex] = determineShape(tokens, i + 1, depth + 1);
                        localShape.push(subShape);
                        i = newIndex;
                    }
                    else if (tok.type === 'b' && tok.value === ']') {
                        break;
                    }
                    else if (tok.type === 'n') {
                        // Base case: numbers at the deepest level
                        localShape.push(1);
                        i++;
                    }
                }

                // Determine the shape based on the collected sub-shapes
                if (localShape.length === 0) {
                    return [1, i];
                }

                // Check consistency of sub-shapes
                const firstSubShape = JSON.stringify(localShape[0]);
                for (let s = 1; s < localShape.length; s++) {
                    if (JSON.stringify(localShape[s]) !== firstSubShape) {
                        error("SYNTAX ERROR: Inconsistent tensor shape detected.");
                    }
                }

                // Current dimension size
                shape.push(localShape.length);
                // Merge the sub-shapes
                if (Array.isArray(localShape[0])) {
                    const mergedSubShape = localShape[0];
                    shape = shape.concat(mergedSubShape);
                }

                return [shape, i + 1];
            }

            // Determine the shape of the tensor
            const [shape, endIndex] = determineShape(tensorTokens, 0, 1);

            // Now extract the actual data
            function extractData(tokens, start, depth) {
                let data = [];
                let i = start;

                while (i < tokens.length) {
                    const tok = tokens[i];
                    if (tok.type === 'b' && tok.value === '[') {
                        const [subData, newIndex] = extractData(tokens, i + 1, depth + 1);
                        data = data.concat(subData);
                        i = newIndex;
                    }
                    else if (tok.type === 'b' && tok.value === ']') {
                        break;
                    }
                    else if (tok.type === 'n') {
                        data.push(tok.value);
                        i++;
                    }
                }

                return [data, i + 1];
            }

            const [data, finalIndex] = extractData(tensorTokens, 0, 1);

            // Validate the number of elements matches the shape
            const totalElements = shape.reduce((a, b) => a * b, 1);
            if (data.length !== totalElements) {
                error("SYNTAX ERROR: Number of elements does not match the tensor shape.");
            }

	    
	    // Create the Float32Array for tensor data
            const tensorData = new Float32Array(data);

            // Create the texture from data
            const { texture, width, height } = createTextureFromData(gl, tensorData);

            // Push the tensor onto the stack
            tensorStack.push({
                shape: shape,
                data: tensorData,
                texture: texture,
                width: width,
                height: height
            });

            // Move the index to the start position
            index = start;
        }
        index--;
    }
}

function debug(message) {
    const h3 = document.createElement('h3');
    h3.style.color = 'red';
    h3.textContent = message;
    document.body.appendChild(h3);
}

function error(message) {
    debug(message);
    throw new Error(message);
}

function clearErrors() {
    const errorElements = document.querySelectorAll('h3[style="color: red;"]');
    errorElements.forEach(element => element.remove());
}

document.getElementById('parse').addEventListener('click', () => {parse();});
document.getElementById('pushIndexTensor').addEventListener('click', () => {setProgram('i' + generateRandomSize(4, 64).join(' '));});
document.getElementById('popTensor').addEventListener('click', () => {setProgram('‚Ü•');});
document.getElementById('pushRandomTensor').addEventListener('click', () => {setProgram('?' + generateRandomSize(6, 64).join(' '));});
document.getElementById('pushSingleton').addEventListener('click', () => {setProgram('(?)');});
document.getElementById('dumpMemory').addEventListener('click', dumpGPUMemory);
</script>
</body>
</html>
