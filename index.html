<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta copyright="Copyright 2024 © Jon DuBois, 4o cookie dough, and o1 honey bun.">
<link rel="icon" href="favicon.png">
<title>Tensor oriented stack programming.</title>
<style>
button {
    margin: 5px;
    padding: 10px;
}
pre {
    white-space: pre;     /* Prevents word wrap */
    font-family: monospace;
    font-size: 10px;      /* Optional: Adjust for readability */
    overflow-x: auto;     /* Adds scrollbar if needed */
    max-width: 100%;      /* Ensures pre doesn't exceed container */
}
</style>
</head>
<body>
<div>
<input type="text" id="programField" placeholder="Enter expression here...">
<button id="parse">Parse</button>
<br>
<button id="pushIndexTensor">Push index tensor</button>
<button id="popTensor">Pop tensor</button>
<button id="pushRandomTensor">Push random tensor</button>
<button id="pushSingleton">Push singleton</button>
<button id="dumpMemory">Dump GPU Memory</button>
</div>
<canvas id="glCanvas" width="64" height="64" style="display: none;"></canvas>
<pre id="output"></pre>
<script>
const maxDim = 4096;
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl2');
const outputElement = document.getElementById('output');

if (!gl) {
    console.error('WebGL 2 not supported');
    document.body.innerHTML = 'WebGL 2 is not supported in your browser.';
}

// Enable the EXT_color_buffer_float extension
const ext = gl.getExtension('EXT_color_buffer_float');
if (!ext) {
    console.error('EXT_color_buffer_float not supported');
    document.body.innerHTML = 'EXT_color_buffer_float is not supported in your browser.';
}

// Stack to hold tensors
let tensorStack = []; // Each tensor is an object {shape: [...], data: Float32Array, texture: WebGLTexture, width, height}

function generateRandomSize(maxDim, maxElements) {
    let shape = [];
    let dims = Math.floor(Math.random() * maxDim) + 1; // Number of dimensions between 1 and maxDim

    let totalElements = 1;
    for (let i = 0; i < dims; i++) {
        let remainingDims = dims - i;
        let maxSize = Math.floor(Math.pow(maxElements / totalElements, 1 / remainingDims));
        if (maxSize <= 1) {
            shape.push(1);
            totalElements *= 1;
        } else {
            let size = Math.floor(Math.random() * maxSize) + 1; 
            shape.push(size);
            totalElements *= size;
        }
    }
    return shape;
}

function generateIndexTensor(size) {
    let totalElements = size.reduce((a, b) => a * b, 1);
    let data = new Float32Array(size.length * totalElements);
    let shape = size.slice(); // Copy of the size array
    shape.push(size.length); // Increase rank by one

    for (let i = 0; i < totalElements; i++) {
        let remainder = i;
        for (let j = size.length - 1; j >= 0; j--) {
            data[i * size.length + j] = remainder % size[j];
            remainder = Math.floor(remainder / size[j]);
        }
    }
    return [shape, data];
}

function generateRandomTensor(shape) {
    let totalElements = shape.reduce((a, b) => a * b, 1);
    let data = new Float32Array(totalElements);

    for (let i = 0; i < totalElements; i++) {
        data[ i ] = Math.random();
    }
    return [shape, data];
}

function createTextureFromData(gl, data) {
    let totalTexels = Math.ceil(data.length / 4); 
    let width = Math.min(totalTexels, maxDim);
    let height = Math.ceil(totalTexels / width);

    // Create a Float32Array with length width * height * 4 (RGBA)
    let textureData = new Float32Array(width * height * 4);
    for (let i = 0; i < data.length; i++) {
        textureData[i] = data[i];
    }

    // Fill the rest of the texture data with zeros if necessary
    for (let i = data.length; i < (width * height * 4); i++) {
        textureData[i] = 0;
    }

    // Create texture
    let texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // Set texture parameters
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    // Allocate texture storage and upload data
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, textureData);

    // Unbind texture
    gl.bindTexture(gl.TEXTURE_2D, null);

    return { texture: texture, width: width, height: height };
}

function pushIndexTensor() {
    let size = generateRandomSize(4, 64);
    let [shape, data] = generateIndexTensor(size);
    let { texture, width, height } = createTextureFromData(gl, data);
    tensorStack.push({
        shape: shape,
        data: data,
        texture: texture,
        width: width,
        height: height
    });
    outputElement.textContent = `Pushed index tensor with shape [${shape.join(', ')}] onto the stack. Stack size: ${tensorStack.length}`;
}

function pushRandomTensor() {
    let size = generateRandomSize(6, 64);
    let [shape, data] = generateRandomTensor(size);
    let { texture, width, height } = createTextureFromData(gl, data);
    tensorStack.push({
        shape: shape,
        data: data,
        texture: texture,
        width: width,
        height: height
    });
    outputElement.textContent = `Pushed random tensor with shape [${shape.join(', ')}] onto the stack. Stack size: ${tensorStack.length}`;
}

function pushSingleton(x) {
    let data = new Float32Array([x]);
    let { texture, width, height } = createTextureFromData(gl, data);
    tensorStack.push({
        shape: [],
        data: data,
        texture: texture,
        width: width,
        height: height
    });
    outputElement.textContent = `Pushed singleton  [${x}] onto the stack. Stack size: ${tensorStack.length}`;
}

function popTensor() {
    if (tensorStack.length > 0) {
        let tensor = tensorStack.pop();
        gl.deleteTexture(tensor.texture);
        outputElement.textContent = `Popped tensor with shape [${tensor.shape.join(', ')}] from the stack. Stack size: ${tensorStack.length}`;
    } else {
        outputElement.textContent = 'Cannot pop: Stack is empty';
    }
}

function formatTensorData(data, shapeArg) {
    let shape = [1, ...shapeArg];
    // Calculate global maximum number length
    const maxNumLength = Math.max(...data.map(num => num.toString().length));
    if (shape.length === 0) { 
        return '[' + data[0] + ']';
    }
    function helper(dimIndex, offset, depth) {
        if (dimIndex === shape.length - 1) {
            // Base case: last dimension
            let elements = [];
            for (let i = 0; i < shape[dimIndex]; i++) {
                let numStr = data[offset + i].toString().padEnd(maxNumLength, ' ');
                elements.push(numStr);
            }
            return elements.join(' ');
        } else {
            // Determine stacking direction based on depth
            let isHorizontal = (depth % 2 === 0);

            // Recursive case
            let blocks = [];
            let size = shape.slice(dimIndex + 1).reduce((a, b) => a * b, 1);
            for (let i = 0; i < shape[dimIndex]; i++) {
                let inner = helper(dimIndex + 1, offset + i * size, depth + 1);
                blocks.push(inner);
            }

            if (isHorizontal) {
                // Stack horizontally with boxes
                let blockLinesArray = blocks.map(block => {
                    let lines = block.split('\n');
                    let maxLineLength = Math.max(...lines.map(line => line.length));
                    let maxLength = Math.max(maxLineLength, maxNumLength);

                    let top = '┌' + '─'.repeat(maxLength + 2) + '┐';
                    let bottom = '└' + '─'.repeat(maxLength + 2) + '┘';
                    let middle = lines.map(line => '│ ' + line.padEnd(maxLength) + ' │');
                    return [top, ...middle, bottom];
                });

                // Determine the maximum height among all blocks
                let maxHeight = Math.max(...blockLinesArray.map(blockLines => blockLines.length));

                // Pad blocks to have the same height
                blockLinesArray = blockLinesArray.map(blockLines => {
                    let width = blockLines[0].length;
                    if (blockLines.length < maxHeight) {
                        let emptyLine = ' '.repeat(width);
                        let padding = Array(maxHeight - blockLines.length).fill(emptyLine);
                        blockLines = [...blockLines, ...padding];
                    }
                    return blockLines;
                });

                // Combine blocks line by line
                let combinedLines = [];
                for (let i = 0; i < maxHeight; i++) {
                    let line = blockLinesArray.map(blockLines => blockLines[i]).join(' ');
                    combinedLines.push(line);
                }
                return combinedLines.join('\n');
            } else {
                // Stack vertically with boxes
                let blockLinesArray = blocks.map(block => {
                    let lines = block.split('\n');
                    let maxLineLength = Math.max(...lines.map(line => line.length));
                    let maxLength = Math.max(maxLineLength, maxNumLength);

                    let top = '┌' + '─'.repeat(maxLength + 2) + '┐';
                    let bottom = '└' + '─'.repeat(maxLength + 2) + '┘';
                    let middle = lines.map(line => '│ ' + line.padEnd(maxLength) + ' │');
                    return [top, ...middle, bottom];
                });

                // Determine the maximum width among all blocks
                let maxWidth = Math.max(...blockLinesArray.map(blockLines => blockLines[0].length));

                // Pad blocks to have the same width
                blockLinesArray = blockLinesArray.map(blockLines => {
                    return blockLines.map(line => line.padEnd(maxWidth));
                });

                // Combine blocks vertically
                let combinedLines = [];
                blockLinesArray.forEach(blockLines => {
                    combinedLines.push(...blockLines);
                });
                return combinedLines.join('\n');
            }
        }
    }
    return helper(0, 0, 0);
}

function dumpGPUMemory() {
    if (tensorStack.length === 0) {
        outputElement.textContent = 'Stack is empty';
        return;
    }

    let output = '';
    for (let i = 0; i < tensorStack.length; i++) {
        let tensor = tensorStack[i];
        let shape = tensor.shape;
        let totalElements = tensor.data.length;
        let width = tensor.width;
        let height = tensor.height;

        // Create a framebuffer and attach the texture
        let framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tensor.texture, 0);

        // Read pixels
        let pixels = new Float32Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, pixels);

        // Extract the data from the pixels
        let data = [];
        for (let j = 0; j < totalElements; j++) {
            data.push(pixels[j]);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(framebuffer);

        output += `Tensor ${i}:\n`;
        output += `Shape: [${shape.join(' ')}]\n`;
        output += `Data:\n${formatTensorData(data, shape)}\n\n`;
    }

    outputElement.textContent = output;
}

function setProgram(x) {
    document.getElementById('programField').value = x + document.getElementById('programField').value;
}

function tokenize(string) {
    const tokens = [];
    let current = '';
    const operators = new Set(['?', '↥', 'i']);
    const brackets = new Set(['[', ']', '(', ')']);
    const whitespace = /\s/;
    
    function addToken(type, value) {
        tokens.push({type, value});
    }
    
    for (let i = 0; i < string.length; i++) {
        const char = string[i];
        
        // Skip whitespaces
        if (whitespace.test(char)) {
            continue;
        }

        // Handle numbers (both integers and decimals, with optional minus sign)
        if ((char === '-' && /\d/.test(string[i+1])) || /\d/.test(char)) {
            current += char;
            let decimalAdded = char === '.';

            while (i + 1 < string.length && (/\d/.test(string[i + 1]) || (!decimalAdded && string[i + 1] === '.'))) {
                if (string[i + 1] === '.') {
                    decimalAdded = true;
                }
                current += string[++i];
            }

            addToken('n', parseFloat(current)); // number
            current = '';
            continue;
        }
        
        // Handle functions (?, ↥, i)
        if (operators.has(char)) {
            addToken('f', char); // function
            continue;
        }
        
        // Handle brackets and parentheses
        if (brackets.has(char)) {
            addToken('b', char); // bracket
            continue;
        }
        
        // Handle invalid characters
        error(`SYNTAX ERROR: Invalid character encountered: ${char}.`);
    }
    
    return tokens;
}

function unshiftTensor(shape, data) {
    let { texture, width, height } = createTextureFromData(gl, data);
    tensorStack.unshift({
        shape: shape,
        data: data,
        texture: texture,
        width: width,
        height: height
    });
    debug( `Pushed tensor with shape [${shape.join(', ')}] onto the stack. Stack size: ${tensorStack.length}` );
}

function parse() {
    clearErrors();
    const program = document.getElementById('programField').value;
    const tokens = tokenize(program);

    let numNumbers = 0; // The number of numbers we've seen in a row.
    let bracketLevel = 0;
    let currentShape = []; // Shape of the current tensor being processed
    let currentArray = []; // To store the last dimension's data

    for (let i = tokens.length - 1; i >= 0; i--) {
        const token = tokens[i];
        if (token.type === 'n') {
            // Accumulate numbers for the current tensor
            numNumbers++;
            currentArray.unshift(token.value);
            if (bracketLevel > 0) {
                if (currentShape.length !== bracketLevel)
                    error("SYNTAX ERROR: Malformed tensor, not all numbers appear at the same depth.");
            }
        } else {
            if (numNumbers > 0) {
                if (bracketLevel === 0) {
                    if (numNumbers === 1)
                        unshiftTensor([], new Float32Array(currentArray));
                    else
                        unshiftTensor([currentArray.length], new Float32Array(currentArray));
                    numNumbers = 0;
                }
            }
            if (token.type === 'b') {
                if (token.value === ']') {
                    if (bracketLevel >= currentShape.length)
                        currentShape.push( 1 );
                    else
                        currentShape[bracketLevel - 1]++
                    bracketLevel++;
                } else if (token.value === '[') {
                    bracketLevel--;
                    if (numNumbers > 0) {
                        currentShape[currentShape.length - 1] = numNumbers;
			numNumbers = 0;
                    }
                    if (bracketLevel < 0)
                        error( "SYNTAX ERROR: Unbalanced square brackets []." );
                    else if (bracketLevel === 0) {
                        unshiftTensor(currentShape, new Float32Array(currentArray));
                        currentShape = [];
			currentArray = [];
                    }
                }
            }
        }
    }            
    if (bracketLevel !== 0)
	error( "SYNTAX ERROR: Unexpected end of program while looking for [." );
    if (numNumbers > 0) {
        if (numNumbers === 1)
	    unshiftTensor([], new Float32Array(currentArray));
        else
	    unshiftTensor([currentArray.length], new Float32Array(currentArray));
    }
}


function debug(message) {
    const h3 = document.createElement('h3');
    h3.style.color = 'red';
    h3.textContent = message;
    document.body.appendChild(h3);
}

function error(message) {
    debug(message);
    throw new Error(message);
}

function clearErrors() {
    const errorElements = document.querySelectorAll('h3[style="color: red;"]');
    errorElements.forEach(element => element.remove());
}

document.getElementById('parse').addEventListener('click', () => {parse();});
document.getElementById('pushIndexTensor').addEventListener('click', () => {setProgram('i' + generateRandomSize(4, 64).join(' '));});
document.getElementById('popTensor').addEventListener('click', () => {setProgram('↥');});
document.getElementById('pushRandomTensor').addEventListener('click', () => {setProgram('?' + generateRandomSize(6, 64).join(' '));});
document.getElementById('pushSingleton').addEventListener('click', () => {setProgram('(?)');});
document.getElementById('dumpMemory').addEventListener('click', dumpGPUMemory);
</script>
</body>
</html>
