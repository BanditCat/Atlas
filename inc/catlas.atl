include'inc\stdlib.atl';
'main.atl';
include'inc\nav.atl';
size;if'started'; // init code goes here



[1024];dim= 1; // constants
[0.2];hscale= 1;
[0.5];hscale;[2];/;0;cat;[0.5];0;cat;hmapCenter= 3;
[0.05];waterLevel= 1;
[30.0];waterFogScale= 1;
[0.0 0.15 0.25];waterColor= 3;
[2048 2048 1];shadowSize= 3;
[0.0001];shadowBias= 1;
[100];softShadows= 1;


dim;first;2;rep;set'texsize' 2;
img'inc\terrain.bmp';0;dup;shape;[1 2 0];s;ttexsize= 1;
6;[1];ttexsize;0;cat;[4];0;cat;
c''''ret[0] = vec4( a( ivec4( 0, tf.y, 2, 0 ) ),
                    a( ivec4( 0, tf.y, 1, 0 ) ),  
                    a( ivec4( 0, tf.y, 0, 0 ) ), 1.0 );' 1 1 4 0;texture;
dim;first;4;std.fractalNoise;
// get minmax
0;dup;minmax;0;dup;last;1;dup;first;-;e;hspan= 1;first;-1;*;e;hbias= 1;


6;texsize;[1];0;cat;c''''ret[0]=( a( ivec4( tf, 0, 0 ) ) + hbias ) / hspan;' 1 1 1 0;texture;
[150 400];set'lrot' 2;
lrot;first;-300;/;[0 1 0];rot; // rot about y
lrot;last;-300;/;[1 0 0];rot;m; // rot about x
set'lightRotation' 16;

std.nav3d;
[0.5 1.0 2.0];std.origin= 3;
[150 400];std.3dnavParam=;

6;windowSize;[4];0;cat;
c''''ret[ 0 ]=vec4( 0 );' 0 1 4 0; // dummy value to pop off in place of display tensor.


l'started'; // init code complete
// Stack here: prevFrame, heightMap, gradient







std.nav3d;std.3dnavParam;set'lrot' 2;
lrot;first;-300;/;[0 1 0];rot; // rot about y
lrot;last;-300;/;[1 0 0];rot;m; // rot about x
0;dup;
set'lightRotation' 16;
0;dup;[0 1];t;
set'lightUnrotation' 16;
[0 0 -1 0];m;unext;[0 3 0];s;[1 -1 1];*;lightDir= 3;
[-0.72 0.72 -0.72 0.72 1.0 5.0];ortho;orthoproj= 16;

// shadow map
1;dup;
// Stack here: heightmapCopy, prevFrame, heightMap, gradient

6;dim;dim;*;first;*;shadowSize;
backface;depth;
c'
vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out float depth;
'
int index = gl_VertexID / 6;
int x = index / int( dim );
int y = index - x * int( dim );
vec4 v = vec4( float(x), float(y), 0.0, 0.0 ) + verts[ gl_VertexID % 6 ];
v.z = af( v.xy ).x * hscale;
v.xy /= dim;
ret = orthoproj*lightUnrotation*( ( vec4( -hmapCenter, 0.0 ) + v.yzxw ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
depth = ( ret.z / ret.w ) * 0.5 + 0.5;
'
in float depth;
'
ret[ 0 ] = depth;
'
1 1 1 0;texture;
backface;depth;

1;bury;
// Stack here: prevFrame, shadowmap, heightMap, gradient

3;dup;3;dup; // duplicate terrain and heightmap
windowSize;set'wdims' 2;
wdims;0;dup;first;1;dup;last;/;0.5;^;e;set'aspect' 1;pop; // set wdims to window dimensions and aspect.





[90];windowSize;0;cat;[0.01 3];0;cat;proj;proj= 16;

// Stack here: the arguments (heightmapcopy, gradientcopy, prevFrame), heightMap, gradient
depth;backface;
6;dim;dim;*;first;*;windowSize;[4];0;cat;
c'
vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out vec3 color;
out vec3 worldPos;
out vec3 normal;
'
int index = gl_VertexID / 6;
int x = index / int( dim );
int y = index - x * int( dim );
vec4 v = vec4( float(x), float(y), 0.0, 0.0 ) + verts[ gl_VertexID % 6 ];
v.z = af( v.xy ).x * hscale;
vec2 c = vec2( 0.0, ( v.z / hscale ) * ttexsize );
color = bf( c ).rgb;

float leftSample = af( v.xy - vec2( 1.0, 0.0 ) ).x * hscale;
float rightSample = af( v.xy + vec2( 1.0, 0.0 ) ).x * hscale;
vec3 nrml1 = vec3( 2.0 / dim, 0.0, leftSample - rightSample );
float upSample = af( v.xy - vec2( 0.0, 1.0 ) ).x * hscale;
float downSample = af( v.xy + vec2( 0.0, 1.0 ) ).x * hscale;
vec3 nrml2 = vec3( 0.0, 2.0 / dim, upSample - downSample );
normal = normalize( cross( nrml1, nrml2 ) ).yzx;


v.xy /= dim;
worldPos = v.yzx;
ret = proj*std_worldUnrotation*( v.yzxw - vec4( std_origin, 0.0 ) );
'
in vec3 color;
in vec3 worldPos;
in vec3 normal;
'
vec3 d = worldPos - std_origin;
vec4 lightPos = orthoproj*lightUnrotation*( vec4( -hmapCenter, 0.0 ) + vec4( worldPos, 1.0 ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
lightPos /= lightPos.w;
lightPos.xyz = lightPos.xyz * 0.5 + 0.5;
float curDepth = lightPos.z;
float centerLightDepth = df( lightPos.xy * shadowSize.xy ).x;
float spread = clamp( ( curDepth - centerLightDepth ) * softShadows, 1.0, 1000.0 );

float shadow = 0.0;
for( float dx = -2.0; dx <= 2.0; ++dx ){
  for( float dy = -2.0; dy <= 2.0; ++dy ){
    vec2 delta = vec2( dx, dy ) * spread;
    float lightDepth = df( lightPos.xy * shadowSize.xy + delta ).x;
    shadow += ( curDepth - shadowBias ) > lightDepth ? 1.0 : 0.0;
  }
}
shadow /= 25.0;
shadow *= 0.7;


float len = length( d );
float t = ( waterLevel - std_origin.y ) / d.y;
if( d.y > 0.0 )
  t = 1.0;
float waterDepth = len * ( 1.0 - t );
float fog = clamp( waterDepth * waterFogScale, 0.0, 1.0 );
float diffuse = dot( normal, lightDir ) * 0.5 + 0.5;
diffuse *= ( 1.0 - shadow );
ret[ 0 ] = vec4( mix( diffuse * color, vec3( 0.0, 0.1, 0.3 ), fog ), 1.0 );
'
4 1 4 0;

6;1;dup;shape;c''''
vec3 ray = normalize(
    vec3(
      ( tf.xy / wdims * 2.0 - 1.0 ) * vec2(aspect, 1.0/aspect), 
      -1.0
    )
);
ray = ( std_worldRotation * vec4( ray, 1.0 ) ).xyz;
float skyness = clamp( dot( ray, vec3( 0.0, 1.0, 0.0 ) ) * 5.0 + 2.3, 0.0, 1.0 );
vec3 skyColor = mix( vec3( 0.3, 0.1, 0.5 ),
                     vec3( 0.1, 0.2, 0.9 ),
                     clamp( dot( lightDir, vec3( 0.0, 1.0, 0.0 ) ), 0.0, 1.0 ) );
float sunness = clamp( dot( lightDir * vec3( -1.0, 1.0, -1.0 ), ray ) * 80.0 - 78.0, 0.0, 1.0 );
skyColor = mix( skyColor, vec3( 1.0, 1.0, 0.3 ), sunness );
ret[ 0 ] = vec4( skyColor * skyness, 1.0 );
' 0 1 4 1;
depth;backface;



//////////////////////////////////////////////////////////////////
// Help and framerate

std.keyState;[58 59 0];s;first;ifn'skipf1';
'Click and drag: rotate view                     ';e;
'Right click: fly forward                        ';e;0;cat;
'w/s/a/d/c/shift/ctrl/space/q/e: fly around      ';e;0;cat;
'Mouse wheel: change fly speed                   ';e;0;cat;
'Hold f key and drag mouse: change light location';e;0;cat;
std.textToTexture;std.blitText;
l'skipf1';
std.keyState;[59 60 0];s;first;std.gamepadState;[13 14 0];s;first;+;ifn'skipf2';
1;timeDelta;/;toString;e;
std.textToTexture;std.blitText;
l'skipf2';
