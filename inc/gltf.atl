include'inc\stdlib.atl';
'inc\\catlas.atl';
include'inc\nav.atl';
size;if'started'; // init code goes here

'inc\\catlas.ktl';unkettle;pop;
[2.0];progress= 1;

[1024];dim= 1; // constants
[0.2];hscale= 1;
[0.5];hscale;[2];/;0;cat;[0.5];0;cat;hmapCenter= 3;
[0.05];waterLevel= 1;
[30.0];waterFogScale= 1;
[0.0 0.15 0.25];waterColor= 3;
[2048 2048 1];shadowSize= 3;
[0.001];shadowBias= 1;
[50];softShadows= 1;
[0.05];sableScale= 1;
[0];timer= 1;
[2000];instanceCount= 1;
[7];instanceVars= 1;


dim;first;2;rep;set'texsize' 2;
img'inc\terrain.bmp';0;dup;shape;[1 2 0];s;ttexsize= 1;
6;[1];ttexsize;0;cat;[4];0;cat;
c''''ret[0] = vec4( a( ivec4( 0, tf.y, 2, 0 ) ),
                    a( ivec4( 0, tf.y, 1, 0 ) ),  
                    a( ivec4( 0, tf.y, 0, 0 ) ), 1.0 );' 1 1 4 0;texture;
dim;first;4;std.fractalNoise;
// get minmax
0;dup;minmax;0;dup;last;1;dup;first;-;e;hspan= 1;first;-1;*;e;hbias= 1;


6;texsize;[1];0;cat;c''''ret[0]=( a( ivec4( tf, 0, 0 ) ) + hbias) / hspan;' 1 1 10 0;texture;
[150 400];set'lrot' 2;
lrot;first;-300;/;[0 1 0];rot; // rot about y
lrot;last;-300;/;[1 0 0];rot;m; // rot about x
set'lightRotation' 16;

std.nav3d;
[0.5 1.0 2.0];std.origin= 3;
[171 134];std.3dnavParam=;

6;windowSize;[2 2];*;[4];0;cat;
c''''ret[ 0 ]=vec4( 0 );' 0 1 4 0; // dummy value to pop off in place of display tensor.

1;
l'started'; // init code complete
loadedKettle;if'kettled';
pop;
progress;unext;ifn'loop4';
unkettle;e;progress= 1;
// load bar
windowSize;wwdims= 2;6;wwdims;[4];0;cat;c''''ret[ 0 ] = tf.x / wwdims.x > 2.0 - progress ? vec4( 0.0 ) : vec4( 1.0 - abs( tf.y - wwdims.y / 2.0 ) / 30.0 );' 0 1 40 0;
continue;
l'loop4';
1;loadedKettle=;
/////////////////////////////////////////////////
// instance init
4;raise;e;animCount= 1;6;raise;6;raise;6;raise;
3;dup;shape;[0 1 0];s;vertexCount= 1;
5;dup;shape;0;dup;[0 1 0];s;frameCount= 1;[1 2 0];s;animCount;/;boneCount= 1;
6;dup;shape;[1 3 0];s;atlasSize= 2;

4;raise; // get indices
0;dup;shape;indexCount= 1;
6;indexCount;instanceCount;instanceVars;*;+;
c'''
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'ret[ 0 ] = t.x < int( indexCount ) ? a( ivec4( t.x, 0, 0, 0 ) ) : hash( vec2( t.xy ), 0.1 );' 1 1 0 0;
4;bury;  // put indices back


/////////////////////////////////////
// bake VAT
3;dup;6;dup;   // duplicate vertex data (a) and bone matrices (b)
6;vertexCount;frameCount;animCount;[2];*;*;0;cat;[4];0;cat;
c'''
mat4 getBoneMat(int frame, int bone, int anim) {
    mat4 m;
    for (int col = 0; col < 4; col++) {
       vec4 val = af(vec3(
           float(col) + 0.5,
           float(anim) + animCount * float(bone) + 0.5,
           float(frame)
       ));
       m[col] = val;
    }
    return m;
}
'
int vertIdx = int(tf.x);
int frameAnim = int(tf.y) / 2;
int posOrNormal = int(tf.y) % 2;
int frame = frameAnim % int(frameCount);
int anim = frameAnim / int(frameCount);

vec4 v = vec4(
    b(ivec4(vertIdx, 0, 0, 0)),
    b(ivec4(vertIdx, 1, 0, 0)),
    b(ivec4(vertIdx, 2, 0, 0)),
    1.0
);

ivec4 bi = ivec4(
    b(ivec4(vertIdx, 8, 0, 0)),
    b(ivec4(vertIdx, 9, 0, 0)),
    b(ivec4(vertIdx, 10, 0, 0)),
    b(ivec4(vertIdx, 11, 0, 0))
);
vec4 weights = vec4(
    b(ivec4(vertIdx, 12, 0, 0)),
    b(ivec4(vertIdx, 13, 0, 0)),
    b(ivec4(vertIdx, 14, 0, 0)),
    b(ivec4(vertIdx, 15, 0, 0))
);
vec2 uv = vec2( b( ivec4( vertIdx, 6, 0, 0 ) ), b( ivec4( vertIdx, 7, 0, 0 ) ) );
vec4 normal = vec4( b( ivec4( vertIdx, 3, 0, 0 ) ), b( ivec4( vertIdx, 4, 0, 0 ) ),
                    b( ivec4( vertIdx, 5, 0, 0 ) ), 1.0 );
mat4 skin = getBoneMat(frame, bi.x, anim) * weights.x +
            getBoneMat(frame, bi.y, anim) * weights.y +
            getBoneMat(frame, bi.z, anim) * weights.z +
            getBoneMat(frame, bi.w, anim) * weights.w;

v = skin * v;
v.w = uv.x;
normal = skin * normal;
normal.w = uv.y;
ret[0] = posOrNormal == 0 ? v : normal;
' 2 1 4 0;
7;bury;



l'kettled';



timer;timeDelta;e;+;timer= 1;
// Stack here: prevFrame, heightMap, gradient







std.nav3d;std.3dnavParam;set'lrot' 2;
lrot;first;-300;/;[0 1 0];rot; // rot about y
lrot;last;-300;/;[1 0 0];rot;m; // rot about x
0;dup;
set'lightRotation' 16;
0;dup;[0 1];t;
set'lightUnrotation' 16;
[0 0 -1 0];m;unext;[0 3 0];s;[1 -1 1];*;lightDir= 3;
[-0.72 0.72 -0.72 0.72 1.0 5.0];ortho;orthoproj= 16;



// Stack here: prevFrame, heightMap, gradient, vertexatrribs, indices, bones, mats, VAT



/////////////////////////////////////////////////////
// shadow map terrain
1;dup;
// Stack here: heightmapCopy, prevFrame, heightMap, gradient

6;dim;dim;*;first;*;shadowSize;
backface;depth;
c'
vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out float depth;
'
int index = gl_VertexID / 6;
int x = index / int( dim );
int y = index - x * int( dim );
vec4 v = vec4( float(x), float(y), 0.0, 0.0 ) + verts[ gl_VertexID % 6 ];
v.z = af( v.xy ).x * hscale;
v.xy /= dim;
ret = orthoproj*lightUnrotation*( ( vec4( -hmapCenter, 0.0 ) + v.yzxw ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
depth = ( ret.z / ret.w ) * 0.5 + 0.5;
'
in float depth;
'
ret[ 0 ] = depth;
'
1 1 1 0;
backface;depth;

////////////////////////////////////////////////////////////////////////////
//  Shadow map sables
//         0          1          2     3     4       5      6     7     8
// stack: shadowmap, prevframe, hmap, grad, vertex, index, bone, mats, vat
5;dup;9;dup;
indexCount;unext;instanceCount;unext;*;
shadowSize;
depth;backface;
c'
out float depth;
'
int vertsPerInstance = int(indexCount);
int instanceID = gl_VertexID / vertsPerInstance;
int localVertID = gl_VertexID % vertsPerInstance;
int index = int( b( ivec4( localVertID, 0, 0, 0 ) ) );
float xCoord = float(index) + 0.5;

int base = vertsPerInstance + instanceID * int(instanceVars);
 vec3 instPos = vec3(
     b(ivec4(base + 0, 0, 0, 0)),
     b(ivec4(base + 1, 0, 0, 0)),
     b(ivec4(base + 2, 0, 0, 0))
 );
 float facing = b(ivec4(base + 3, 0, 0, 0));
 float animIdx = b(ivec4(base + 4, 0, 0, 0));
 float animStart = b(ivec4(base + 5, 0, 0, 0));
int anim = int(mod(lrot.y / 30.0 + animIdx * 10.0, float(frameCount))) % int( animCount ); 
float frame = mod(lrot.x / 30.0 + timer * 24.0 + animStart * 10.0, frameCount);
int f0 = int( frame );
int f1 = ( f0 + 1 ) % int( frameCount );
float lerp = fract( frame );

int frameAnim0 = f0 + anim * int(frameCount);
int frameAnim1 = f1 + anim * int(frameCount);
float yPos0 = float(frameAnim0 * 2) + 0.5;
float yPos1 = float(frameAnim1 * 2) + 0.5;
vec4 v0 = af( vec4(xCoord, yPos0, 0.0, 0.0 ) );
vec4 v1 = af( vec4(xCoord, yPos1, 0.0, 0.0 ) );
vec4 v = v1 * lerp + v0 * ( 1.0 - lerp );

v.w = 1.0;
v.xyz *= sableScale;
v.xyz += instPos;
ret = orthoproj*lightUnrotation*( ( vec4( -hmapCenter, 0.0 ) + v ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
depth = ( ret.z / ret.w ) * 0.5 + 0.5;
'
in float depth;
'
ret[ 0 ] = depth;
' 2 1 1 1;
depth;backface;texture;











3;dup;3;dup; // duplicate terrain and heightmap
windowSize;[2 2];*;set'wdims' 2;
wdims;0;dup;first;1;dup;last;/;0.5;^;e;set'aspect' 1;pop; // set wdims to window dimensions and aspect.


[90];windowSize;[2 2];*;0;cat;[0.01 3];0;cat;proj;proj= 16;

// Stack here: the arguments (heightmapcopy, gradientcopy, shadowMap, prevFrame), heightMap, gradient
//2;dup;5;bury;print;   // OOPS dont do this, itll deep copy
2;raise;4;bury;4;dup;2;bury;
depth;backface;
6;dim;dim;*;first;*;windowSize;[2 2];*;[4];0;cat;
c'
vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out vec3 color;
out vec3 worldPos;
out vec3 normal;
'
int index = gl_VertexID / 6;
int x = index / int( dim );
int y = index - x * int( dim );
vec4 v = vec4( float(x), float(y), 0.0, 0.0 ) + verts[ gl_VertexID % 6 ];
v.z = af( v.xy ).x * hscale;
vec2 c = vec2( 0.0, ( v.z / hscale ) * ttexsize );
color = bf( c ).rgb;

float leftSample = af( v.xy - vec2( 1.0, 0.0 ) ).x * hscale;
float rightSample = af( v.xy + vec2( 1.0, 0.0 ) ).x * hscale;
vec3 nrml1 = vec3( 2.0 / dim, 0.0, leftSample - rightSample );
float upSample = af( v.xy - vec2( 0.0, 1.0 ) ).x * hscale;
float downSample = af( v.xy + vec2( 0.0, 1.0 ) ).x * hscale;
vec3 nrml2 = vec3( 0.0, 2.0 / dim, upSample - downSample );
normal = normalize( cross( nrml1, nrml2 ) ).yzx;


v.xy /= dim;
worldPos = v.yzx;
ret = proj*std_worldUnrotation*( v.yzxw - vec4( std_origin, 0.0 ) );
'
in vec3 color;
in vec3 worldPos;
in vec3 normal;
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
vec3 d = worldPos - std_origin;
vec4 lightPos = orthoproj*lightUnrotation*( vec4( -hmapCenter, 0.0 ) + vec4( worldPos, 1.0 ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
lightPos /= lightPos.w;
lightPos.xyz = lightPos.xyz * 0.5 + 0.5;
float curDepth = lightPos.z;
float centerLightDepth = cf( lightPos.xy * shadowSize.xy ).x;
float spread = clamp( ( curDepth - centerLightDepth ) * softShadows, 1.0, 100000000.0 );


float shadow = 0.0;
for( float dx = -0.5; dx <= 0.5; ++dx ){
  for( float dy = -0.5; dy <= 0.5; ++dy ){
    vec2 jitter = vec2( hash( vec2( dx, dy ), timer ), hash( vec2( dx + 10.0, dy ), timer ) ) - 0.5;
    vec2 delta = ( vec2( dx, dy ) + jitter ) * spread;

    float lightDepth = cf( lightPos.xy * shadowSize.xy + delta ).x;
    shadow += ( curDepth - shadowBias ) > lightDepth ? 1.0 : 0.0;
  }
}
shadow /= 4.0;
shadow *= 0.5;


float len = length( d );
float t = ( waterLevel - std_origin.y ) / d.y;
if( d.y > 0.0 )
  t = 1.0;
float waterDepth = len * ( 1.0 - t );
float fog = clamp( waterDepth * waterFogScale, 0.0, 1.0 );
float diffuse = dot( normal, lightDir ) * 0.5 + 0.5;
diffuse *= ( 1.0 - shadow );
ret[ 0 ] = vec4( mix( diffuse * color, vec3( 0.0, 0.1, 0.3 ), fog ), 1.0 );
'
4 1 40 0;

6;1;dup;shape;c''''
vec3 ray = normalize(
    vec3(
      ( tf.xy / wdims * 2.0 - 1.0 ) * vec2(aspect, 1.0/aspect), 
      -1.0
    )
);
ray = ( std_worldRotation * vec4( ray, 1.0 ) ).xyz;
float skyness = clamp( dot( ray, vec3( 0.0, 1.0, 0.0 ) ) * 5.0 + 2.3, 0.0, 1.0 );
vec3 skyColor = mix( vec3( 0.3, 0.1, 0.5 ),
                     vec3( 0.1, 0.2, 0.9 ),
                     clamp( dot( lightDir, vec3( 0.0, 1.0, 0.0 ) ), 0.0, 1.0 ) );
float sunness = clamp( dot( lightDir * vec3( -1.0, 1.0, -1.0 ), ray ) * 80.0 - 78.0, 0.0, 1.0 );
skyColor = mix( skyColor, vec3( 1.0, 1.0, 0.3 ), sunness );
ret[ 0 ] = vec4( skyColor * skyness, 1.0 );
' 0 1 40 1;
depth;backface;



7;dup;6;dup;10;dup; 5;raise;3;bury;// Stack here: VAT copy, indices copy, mats copy, shadowmap, frame, hmap, gradient, vertexAtribs, indices, bones, mats, VAT
indexCount;unext;instanceCount;unext;*;
5;dup;shape;
depth;backface;
c'
out vec3 normal;
out vec2 uv;
out vec3 worldPos;
flat out float mat;
'
mat = 0.0;
int vertsPerInstance = int(indexCount);
int instanceID = gl_VertexID / vertsPerInstance;
int localVertID = gl_VertexID % vertsPerInstance;
int index = int( b( ivec4( localVertID, 0, 0, 0 ) ) );
float xCoord = float(index) + 0.5;

int base = vertsPerInstance + instanceID * int(instanceVars);
 vec3 instPos = vec3(
     b(ivec4(base + 0, 0, 0, 0)),
     b(ivec4(base + 1, 0, 0, 0)),
     b(ivec4(base + 2, 0, 0, 0))
 );
 float facing = b(ivec4(base + 3, 0, 0, 0));
 float animIdx = b(ivec4(base + 4, 0, 0, 0));
 float animStart = b(ivec4(base + 5, 0, 0, 0));
 float tint = b(ivec4(base + 6, 0, 0, 0));
int anim = int(mod(lrot.y / 30.0 + animIdx * 10.0, float(frameCount))) % int( animCount ); 
float frame = mod(lrot.x / 30.0 + timer * 24.0 + animStart * 10.0, frameCount);
int f0 = int( frame );
int f1 = ( f0 + 1 ) % int( frameCount );
float lerp = fract( frame );

int frameAnim0 = f0 + anim * int(frameCount);
int frameAnim1 = f1 + anim * int(frameCount);
float yPos0 = float(frameAnim0 * 2) + 0.5;
float yPos1 = float(frameAnim1 * 2) + 0.5;
float yNrm0 = float(frameAnim0 * 2 + 1) + 0.5;
float yNrm1 = float(frameAnim1 * 2 + 1) + 0.5;
vec4 v0 = af( vec4(xCoord, yPos0, 0.0, 0.0 ) );
vec4 v1 = af( vec4(xCoord, yPos1, 0.0, 0.0 ) );
vec4 n0 = af( vec4(xCoord, yNrm0, 0.0, 0.0 ) );
vec4 n1 = af( vec4(xCoord, yNrm1, 0.0, 0.0 ) );
vec4 n = n1 * lerp + n0 * ( 1.0 - lerp );
vec4 v = v1 * lerp + v0 * ( 1.0 - lerp );

uv = vec2( v.w, n.w );
v.w = 1.0;
n.w = 1.0;
normal = normalize( n.xyz );
v.xyz *= sableScale;
v.xyz += instPos;
worldPos = v.xyz;
ret = proj*std_worldUnrotation*( v - vec4( std_origin, 0.0 ) );
'
in vec3 normal;
in vec2 uv;
in vec3 worldPos;
flat in float mat;

float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
vec2 muv = fract( uv );

vec4 color = cf( vec3( muv * atlasSize, mat * 2.0 ) );
//if( color.a < 0.5 )  discard;


// // Combine
vec3 diffuse = color.rgb;
vec3 L = normalize(lightDir * vec3(-1.0, 1.0, -1.0));


vec4 lightPos = orthoproj*lightUnrotation*( vec4( -hmapCenter, 0.0 ) + vec4( worldPos, 1.0 ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
lightPos /= lightPos.w;
lightPos.xyz = lightPos.xyz * 0.5 + 0.5;
float curDepth = lightPos.z;

float shadow = 0.0;
for( float dx = -0.5; dx <= 0.5; ++dx ){
  for( float dy = -0.5; dy <= 0.5; ++dy ){
    vec2 jitter = vec2( hash( vec2( dx, dy ), timer ), hash( vec2( dx + 10.0, dy ), timer ) ) - 0.5;
    vec2 delta = ( vec2( dx, dy ) + jitter ) * 1.0; // no spread calc needed for small objects
    float lightDepth = df( lightPos.xy * shadowSize.xy + delta ).x;
    shadow += ( curDepth - shadowBias ) > lightDepth ? 1.0 : 0.0;
  }
}
shadow = shadow / 4.0 * 0.5;

ret[ 0 ] = vec4( diffuse * dot( normal, L ) * (1.0 - shadow), 1.0 );
// //ret[0] = vec4(vec3(roughness), 1.0);
// //ret[ 0 ] = vec4( clamp( dot( finalNormal, lightDir * vec3( -1.0, 1.0, -1.0 ) ), 0.2, 1.0 ) * color.rgb , 1.0 );
// //ret[ 0 ] = vec4( uv.x, uv.y, 0.0, 1.0 );
// //ret[ 0 ] = vec4( color, 1.0 );
' 4 1 40 1;
depth;backface;




// 6;dup;6;dup;6;dup;6;dup;
// indexCount;unext;instanceCount;unext;*;


// 5;dup;shape;
// depth;backface;
// c'
// vec3 hsv2rgb(vec3 c) {
//     vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
//     return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
// }
// mat4 getBoneMat(int frame, int bone, int anim) {
//     mat4 m;
//     for (int col = 0; col < 4; col++) {
//        vec4 val = cf(vec3(
//            float(col) + 0.5,                              // x: column within the 4-wide texture
//            float(anim) + animCount * float(bone) + 0.5,   // y: row 
//            float(frame)                                  // z: layer (frame)
//        ));
//        m[col] = val;
//     }
//     return m;
// }
// mat4 getLerpMat(int f0, int f1, int bone, int anim, float t) {
//     mat4 m0 = getBoneMat(f0, bone, anim);
//     mat4 m1 = getBoneMat(f1, bone, anim);
//     // Manual lerp: result = start * (1 - t) + end * t
//     return m0 * (1.0 - t) + m1 * t; 
// }
// out vec3 normal;
// out vec2 uv;
// out vec3 worldPos;
// flat out float mat;
// '
// int vertsPerInstance = int(indexCount);
// int instanceID = gl_VertexID / vertsPerInstance;
// int localVertID = gl_VertexID % vertsPerInstance;
// int base = vertsPerInstance + instanceID * int(instanceVars);
// vec3 instPos = vec3(
//     b(ivec4(base + 0, 0, 0, 0)),
//     b(ivec4(base + 1, 0, 0, 0)),
//     b(ivec4(base + 2, 0, 0, 0))
// );
// float facing = b(ivec4(base + 3, 0, 0, 0));
// float animIdx = b(ivec4(base + 4, 0, 0, 0));
// float animStart = b(ivec4(base + 5, 0, 0, 0));
// float tint = b(ivec4(base + 6, 0, 0, 0));

// int index = int( b( ivec4( localVertID, 0, 0, 0 ) ) );
// vec4 v = vec4( a( ivec4( index, 0, 0, 0 ) ), a( ivec4( index, 1, 0, 0 ) ), a( ivec4( index, 2, 0, 0 ) ), 1.0 );
// normal = vec3( a( ivec4( index, 3, 0, 0 ) ), a( ivec4( index, 4, 0, 0 ) ), a( ivec4( index, 5, 0, 0 ) ) );
// uv = vec2( a( ivec4( index, 6, 0, 0 ) ), a( ivec4( index, 7, 0, 0 ) ) );
// vec4 bones = vec4( a( ivec4( index, 8, 0, 0 ) ), a( ivec4( index, 9, 0, 0 ) ), a( ivec4( index, 10, 0, 0 ) ),
//                    a( ivec4( index, 11, 0, 0 ) ) );
// vec4 weights = vec4( a( ivec4( index, 12, 0, 0 ) ), a( ivec4( index, 13, 0, 0 ) ),
//                      a( ivec4( index, 14, 0, 0 ) ), a( ivec4( index, 15, 0, 0 ) ) );
// mat = a( ivec4( index, 16, 0, 0 ) );

// // Animation Logic
// float playHead = mod(lrot.x / 30.0 + timer * 24.0 + animStart * 10.0, frameCount);
// int f0 = int(playHead);
// int f1 = (f0 + 1) % int( frameCount ); 
// float t = fract(playHead);

// int anim = int(mod(lrot.y / 30.0 + animIdx * 10.0, float(frameCount))) % int( animCount ); 

// ivec4 bi = ivec4(bones);

// // Blend the blend
// mat4 skin = getLerpMat(f0, f1, bi.x, anim, t) * weights.x +
//             getLerpMat(f0, f1, bi.y, anim, t) * weights.y +
//             getLerpMat(f0, f1, bi.z, anim, t) * weights.z +
//             getLerpMat(f0, f1, bi.w, anim, t) * weights.w;

// v = skin * v;
// v.xyz = v.xyz / 10.0;
// v.xyz += instPos;
// worldPos = v.xyz;
// normal = mat3(skin) * normal;

// ret = proj*std_worldUnrotation*( v - vec4( std_origin, 0.0 ) );
// '
// in vec3 normal;
// in vec2 uv;
// in vec3 worldPos;
// flat in float mat;
// '
// vec2 muv = fract( uv );

// vec4 color = df( vec3( muv * atlasSize, mat * 2.0 ) );
// //if( color.a < 0.5 )  discard;
// vec4 orm = df( vec3( muv * atlasSize, mat * 2.0 + 1.0 ) );
// float packedB = orm.b * 255.0;
// float metallic = floor(packedB / 64.0) / 3.0;  // 0-3 ? 0.0-1.0
// float roughness = max(mod(packedB, 64.0) / 63.0, 0.04);

// float ao = orm.a;

// vec3 L = normalize(lightDir * vec3(-1.0, 1.0, -1.0));
// vec3 V = normalize(std_origin - worldPos);  // need to pass worldPos from vert
// vec3 H = normalize(L + V);



// // Combine
// vec3 diffuse = color.rgb;

// ret[ 0 ] = vec4( diffuse * dot( normal, L ), 1.0 );
// //ret[0] = vec4(vec3(roughness), 1.0);
// //ret[ 0 ] = vec4( clamp( dot( finalNormal, lightDir * vec3( -1.0, 1.0, -1.0 ) ), 0.2, 1.0 ) * color.rgb , 1.0 );
// //ret[ 0 ] = vec4( uv.x, uv.y, 0.0, 1.0 );
// //ret[ 0 ] = vec4( color, 1.0 );
// ' 4 1 40 1;
// depth;backface;

//////////////////////////////////////////////////////////////////
// Help and framerate

std.keyState;[58 59 0];s;first;ifn'skipf1';
'Click and drag: rotate view                     ';e;
'Right click: fly forward                        ';e;0;cat;
'w/s/a/d/c/shift/ctrl/space/q/e: fly around      ';e;0;cat;
'Mouse wheel: change fly speed                   ';e;0;cat;
'Hold f key and drag mouse: change light location';e;0;cat;
std.textToTexture;std.blitText;
l'skipf1';
std.keyState;[59 60 0];s;first;std.gamepadState;[13 14 0];s;first;+;ifn'skipf2';
'FPS:';1;timeDelta;/;toString;0;cat;' Hours:';0;cat;time;first;toString;0;cat;' Seconds:';0;cat;time;last;toString;0;cat;e;
std.textToTexture;std.blitText;
l'skipf2';


// generate mipmaps
texture;