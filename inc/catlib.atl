workspace'cat';
stdlibInited;if'stdlibInitDone';
size;ifn'dontQuitEarly';quit;l'dontQuitEarly';  // If we have commandline arguments, quit, to preserve the startup logic of scripts which depend on the stack being empty.
1;stdlibInited=;
0;512;rep;oldKeys=;
0;21;rep;oldGamepad=;
0;6;rep;oldInput=;
0;21;rep;gamepadState=;
0;21;rep;gamepadPresses=;
0;21;rep;gamepadReleases=;
0;512;rep;keyState=;
0;512;rep;keyPresses=;
0;512;rep;keyReleases=;
0;512;rep;inputState=;
0;512;rep;inputPresses=;
0;512;rep;inputReleases=;
0;lastMouseWheel=;
0;mouseWheel=;
[0 0];rotxy=;

// globals
[3 3];mouseDiv=;
[0.04];deadZone=;

l'stdlibInitDone'; // Init code

keys;keyState=;
// deal with fractional mousewheels.
mouseWheel;lastMouseWheel=;
input;0;dup;inputState=;[2 3 0];s;first;mouseWheel=;
0;mwheelDelta=;
mouseWheel;lastMouseWheel;-;ifn'noincrementmw';
0;mouseWheel;>;if'noincrementmw';
1;mwheelDelta=;
l'noincrementmw';
lastMouseWheel;mouseWheel;-;ifn'nodecrementmw';
mouseWheel;0;>;if'nodecrementmw';
-1;mwheelDelta=;
l'nodecrementmw';
inputState;[0 2 0];s;mwheelDelta;e;0;cat;inputState;[3 6 0];s;0;cat;inputState=;

gamepad;0;dup;shape;first;ifn'nogamepad';
first;
1;if'gamepadDone';
l'nogamepad';
pop;0;21;rep;
l'gamepadDone';

// deadzones
0;dup;[2 4 0];s;l;deadZone;first;>;if'nodeadZoneleft';
0;dup;[0 2 0];s;[0 0];0;cat;1;raise;[4 21 0];s;0;cat;
l'nodeadZoneleft';
0;dup;[4 6 0];s;l;deadZone;first;>;if'nodeadZoneright';
0;dup;[0 4 0];s;[0 0];0;cat;1;raise;[6 21 0];s;0;cat;
l'nodeadZoneright';



gamepadState=; // Set input variables, it's important to do this just once per frame for smoothest performance

1;512;rep;
oldKeys;-;
keyState;*;keyPresses=;
1;512;rep;
keyState;-;
oldKeys;*;keyReleases=;
keyState;oldKeys=;  // Calculate releases and presses

1;21;rep;
oldGamepad;-;
gamepadState;*;gamepadPresses=;
1;21;rep;
gamepadState;-;
oldGamepad;*;gamepadReleases=;
gamepadState;oldGamepad=;

1;6;rep;
oldInput;-;
inputState;*;inputPresses=;
1;6;rep;
inputState;-;
oldInput;*;inputReleases=;
inputState;oldInput=;




1;if'stdlibend'; // Jump past functions



////////////////////////////////////////////////////////////////////////////////
// nav3d
// This function takes 0 arguments but sets origin (a 3 vec) and worldRotation/
// worldUnrotation (4x4 matrices) according to inputs.

l'nav3d';
nav3dInited;if'nav3dInitDone';
[0 0 0];velocity=;
1;speed=;
[0 0 0];origin= 3;
[0 0];3dnavParam=;
0;[0 1 0];rot;worldRotation= 16;
0;[0 1 0];rot;worldUnrotation= 16;
1;nav3dInited=;
l'nav3dInitDone';

//0.90;inputState;[2 3 0];s;[-1];*;first;^;speed;*;speed=;

keyState;[15 16 0];s;first;ifn'lkeyskip'; 
inputState;[0 2 0];s;3dnavParam;+;3dnavParam=;
l'lkeyskip';

[0 0 0];accel=;
keyState;[26 27 0];s;first;ifn'wkeyskip';
[0 0 -1];
accel;+;accel=;
l'wkeyskip';
keyState;[22 23 0];s;first;ifn'skeyskip';
[0 0 1];
accel;+;accel=;
l'skeyskip';
keyState;[4 5 0];s;first;ifn'akeyskip';
[-1 0 0];
accel;+;accel=;
l'akeyskip';
keyState;[7 8 0];s;first;ifn'dkeyskip';
[1 0 0];
accel;+;accel=;
l'dkeyskip';
keyState;[44 45 0];s;keyState;[225 226 0];s;+;first;ifn'spkeyskip';
[0 1 0];
accel;+;accel=;
l'spkeyskip';
keyState;[224 225 0];s;keyState;[6 7 0];s;+;first;ifn'ctkeyskip';
[0 -1 0];
accel;+;accel=;
l'ctkeyskip';
0;rotza=;

rotza;timeDelta;165;*;2;^;*;rotza=;
//rotzv;rotza;+;rotzv=;
rotzv;0.95;timeDelta;165;*;^;*;rotzv=;



rotxy;worldUnrotation;[1 2 0];s;first;[0 3 0];s;up=;
0;dup;first;
-300;/;up;rot;worldRotation;m;worldRotation= 16;
last;
worldUnrotation;[0 1 0];s;first;[0 3 0];s;right=;
-300;/;right;rot;worldRotation;m;worldRotation= 16;
worldUnrotation;[2 3 0];s;first;[0 3 0];s;forward=;
rotzv;
1500;/;forward;rot;worldRotation;m;worldRotation= 16;
worldRotation;[0 1];t;worldUnrotation= 16;

// Roll error = dot(cross(up, worldY), forward)
// cross(up, (0,1,0)) = (-up.z, 0, up.x)
// dot with forward = -up.z*forward.x + up.x*forward.z

up;[0 1 0];s;first;forward;[2 3 0];s;first;*;  // up.x * forward.z
up;[2 3 0];s;first;forward;[0 1 0];s;first;*;  // up.z * forward.x
-;  // roll error
200;*;timeDelta;165;*;*;
rotzv=;



worldRotation;accel;timeDelta;165;*;3;rep;*;[1];0;cat;m;unext;[0 3 0];s;accel=;
velocity;accel;speed;3;rep;*;+;velocity=;
velocity;[0.95 0.95 0.95];timeDelta;165;*;3;rep;^;*;velocity=;

origin;velocity;timeDelta;40;/;3;rep;*;+;origin= 3;


[0 0 0];joymove=;
gamepadState;[0 1 0];s;first;3;rep;[0 0 1];*;joymove;+;joymove=;
gamepadState;[1 2 0];s;first;3;rep;[0 0 -1];*;joymove;+;joymove=;
gamepadState;[2 3 0];s;first;3;rep;[1 0 0];*;joymove;+;joymove=;
gamepadState;[3 4 0];s;first;3;rep;[0 -1 0];*;joymove;+;joymove=;
gamepadState;[16 17 0];s;first;ifn'skipgpnullmove';
joymove;[0 0 1];*;joymove=;
l'skipgpnullmove';
inputState;[5 6 0];s;first;ifn'skipmiddlemove';
inputState;[0 2 0];s;[1 -1];*;mouseDiv;/;[0];0;cat;joymove;+;joymove=;
inputState;[4 5 0];s;first;ifn'skipmiddlemove';
joymove;[0 0 -1];+;joymove=;
l'skipmiddlemove';


gamepadState;[9 10 0];s;first;ifn'nogpup';
[0];timeDelta;-300;*;e;0;cat;3dnavParam;+;3dnavParam=;
l'nogpup';
gamepadState;[11 12 0];s;first;ifn'nogpdown';
[0];timeDelta;300;*;e;0;cat;3dnavParam;+;3dnavParam=;
l'nogpdown';
gamepadState;[10 11 0];s;first;ifn'nogpright';
timeDelta;300;*;e;[0];0;cat;3dnavParam;+;3dnavParam=;
l'nogpright';
gamepadState;[12 13 0];s;first;ifn'nogpleft';
timeDelta;-300;*;e;[0];0;cat;3dnavParam;+;3dnavParam=;
l'nogpleft';
// gamepadState;[18 19 0];s;first;ifn'nogpbty';
// timeDelta;5;*;speed;+;speed=;
// l'nogpbty';
// gamepadState;[15 16 0];s;first;ifn'nogpbta';
// timeDelta;-5;*;speed;+;speed=;
// speed;0;dup;0.1;-;if'speedPositive';pop;0.1;l'speedPositive';speed=;
// l'nogpbta';

worldRotation;joymove;[1];0;cat;m;unext;[0 3 0];s;joymove=;
joymove;timeDelta;speed;*;0.3;*;3;rep;*;origin;+;origin= 3;

return;




////////////////////////////////////////////////////////////////////////////////
// textAreaToFlatTexture
// This function takes 2 arguments, a string character matrix formed like so:
// 'Hello';e;
// 'world';e;0;cat;
// 'more ';e;0;cat;
// 'text ';e;0;cat;
// and a 4 vector representing the offset and size to draw [xoffset yoffset
// xsize ysize]. The function returns 1 tensor: the text texture itself.
l'textAreaToFlatTexture';
0;dup;[0 2 0];s;textOffset= 2;[2 4 0];s;textSize=;
[0 1];t;1;r;
img'inc\font.bmp';
6;textSize;[1];0;cat;
c''''
float x = (tf.x - 1.0) + cat_textOffset.x;
float y = tf.y + cat_textOffset.y;
ret[0] =  ( mod( floor( x ), 6.0 ) != 5.0 ?
          a( ivec4( mod( floor( x ), 6.0 ),
          mod( y, 8.0 ) + 1328.0 - 8.0 * b( ivec4( floor( x / 6.0 ), floor( y / 8.0 ), 0.0, 0.0 ) )
	  ,1.0, 0.0 ) ) : 1.0 );
' 2 1 10 0;
return;


////////////////////////////////////////////////////////////////////////////////
// textToTexure
// This function takes 1 argument, a string character matrix formed like so:
// 'Hello';e;
// 'world';e;0;cat;
// 'more ';e;0;cat;
// 'text ';e;0;cat;
// The function returns 1 tensor: the text texture itself.

l'textToTexture';
[4];tzoom= 1;
[0 1];t;1;r; // Adjust char matrix
img'inc\font.bmp'; // load font
6;2;dup;shape;[6 8];*;[1 1];+;tzoom;0;dup;0;cat;*;[1];0;cat;
c''''
float x = ( tf.x - cat_tzoom ) / cat_tzoom;
float y = tf.y / cat_tzoom;
ret[0] =  ( mod( floor( x ), 6.0 ) != 5.0 ?
          a( ivec4( mod( floor( x ), 6.0 ),
          mod( y, 8.0 ) + 1328.0 - 8.0 * b( ivec4( floor( x / 6.0 ), floor( y / 8.0 ), 0.0, 0.0 ) )
	  ,1.0, 0.0 ) ) : 1.0 );
' 2 1 10 0;texture;
return;




////////////////////////////////////////////////////////////////////////////////
// blitText
// This function takes two tensors, a text texture to blit, and a display tensor
// to blit it onto.

l'blitText';
[10 10];toffset= 2;
6;1;dup;shape;tsize= 3;2;dup;shape;0;dup;wsize= 3;windowSize;wsize;[0 2 0];s;/;wmult= 2;
c'
vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
'
int index = gl_VertexID / 6;
vec4 v = verts[ gl_VertexID % 6 ];
v.xy *= cat_tsize.xy / ( cat_wsize.xy * 2.0 );
v.xy += cat_toffset.xy / cat_wsize.xy;
v.xy /= cat_wmult;

ret = v * 2.0 - 1.0;

''
ret[0] = af( ( tf * cat_wmult - cat_toffset ) * 2.0 ).xxxx;
' 1 1 400 1;
return;




////////////////////////////////////////////////////////////////////////////////
// perlin
// This function takes 4 arguments, gradient grid size, texture size, amplitude,
// and random seed.  The return value is 1 tensor: a perlin noise tensor.


l'perlin';  
randseed= 1;
amp= 1;
2;rep;texsize= 2;

2;rep;0;dup;gradsize= 2;pop;6;gradsize;[2];0;cat;
c'''  // Push the gradients.
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
ret[0]=t.z == 0 ? sin( hash( vec2( t.xy ), cat_randseed ) * 2.0 * 3.1415928 ) :
                  cos( hash( vec2( t.xy ), cat_randseed ) * 2.0 * 3.1415928 );
' 0 1 0 0;

6;texsize;
c'''
float fade( float x ){
    return x*x*x*(x*(x*6.0 - 15.0)+10.0);
}
'
vec2 c1 = vec2( t.xy ) * cat_gradsize / cat_texsize;
vec2 fract = fract( c1 );
ivec2 ic1 = ivec2( c1 );
ivec2 ic2 = ic1 + ivec2( 1, 0 );
ivec2 ic3 = ic1 + ivec2( 0, 1 );
ivec2 ic4 = ic1 + ivec2( 1, 1 );
c1 = vec2( a( ivec4( ic1, 0, 0 ) ), a( ivec4( ic1, 1, 0 ) ) );
vec2 c2 = vec2( a( ivec4( ic2, 0, 0 ) ), a( ivec4( ic2, 1, 0 ) ) );
vec2 c3 = vec2( a( ivec4( ic3, 0, 0 ) ), a( ivec4( ic3, 1, 0 ) ) );
vec2 c4 = vec2( a( ivec4( ic4, 0, 0 ) ), a( ivec4( ic4, 1, 0 ) ) );
float fc1 = dot( c1, fract - vec2( 0, 0 ) );
float fc2 = dot( c2, fract - vec2( 1, 0 ) );
float fc3 = dot( c3, fract - vec2( 0, 1 ) );
float fc4 = dot( c4, fract - vec2( 1, 1 ) );
float u  = fade( fract.x );
float v  = fade( fract.y );
float v1 = mix( fc1, fc2, u );
float v2 = mix( fc3, fc4, u );
float v3 = mix( v1, v2, v );
ret[0]=cat_amp*(v3 * 0.5 + 0.5);
' 1 1 0 0;
return;




////////////////////////////////////////////////////////////////////////////////
// fractalNoise
// This function takes 2 arguments, initial grid size, and texture size and
// returns a tensor with multiple combined octaves of perlin noise.

l'fractalNoise';
fngradsize=;
fntexsize=;
[0.5];fnamp=;
[1];fnseed=;

fngradsize;fntexsize;fnamp;fnseed;perlin;

l'fnloop';
fngradsize;2;*;fngradsize=;
fnamp;[0.5];*;fnamp=;
fnseed;[1.2];+;fnseed=;
fngradsize;fntexsize;fnamp;fnseed;perlin;
6;fntexsize;2;rep;c''''ret[0]=a(t)+b(t);' 2 1 0 0;
fntexsize;fngradsize;/;4;-;if'fnloop';
return;







////////////////////////////////////////////////////////////////////////////////
// perlin 3d
// This function takes 4 arguments, gradient grid size, texture size, amplitude,
// and random seed.  The return value is 1 tensor: a perlin noise tensor.


l'perlin3d';  
randseed= 1;
amp= 1;
texsize3d= 3;

0;dup;gradsize3d= 3;pop;6;gradsize3d;[3];0;cat;
c'''  // Push the gradients.
float hash( vec3 p, float time ){
    float h = dot( p, vec3( 127.1, 311.7, 1337.3 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
float z = hash( vec3( t.xyz ), cat_randseed ) * 2.0 - 1.0;  // uniform in [-1, 1]
float theta =  hash( vec3( t.xyz ), cat_randseed ) * 2.0 * 3.1415926535897932384626433832795;
float r = sqrt( 1.0 - z * z );
vec3 g = vec3( r * cos(theta), r * sin(theta), z );
ret[ 0 ]= g[ t.w ];
' 0 1 0 0;

6;texsize3d;
c'''
float fade( float x ){
    return x * x * x * ( x * ( x * 6.0 - 15.0 ) + 10.0 );
}
'
vec3 c1 = vec3( t.xyz ) * cat_gradsize3d / cat_texsize3d;
vec3 f = fract( c1 );
ivec3 ic1 = ivec3( c1 );
ivec3 ic2 = ic1 + ivec3( 1, 0, 0 );
ivec3 ic3 = ic1 + ivec3( 0, 1, 0 );
ivec3 ic4 = ic1 + ivec3( 1, 1, 0 );
ivec3 ic5 = ic1 + ivec3( 0, 0, 1 );
ivec3 ic6 = ic1 + ivec3( 1, 0, 1 );
ivec3 ic7 = ic1 + ivec3( 0, 1, 1 );
ivec3 ic8 = ic1 + ivec3( 1, 1, 1 );
c1 = vec3( a( ivec4( ic1, 0 ) ), a( ivec4( ic1, 1 ) ), a( ivec4( ic1, 2 ) ) );
vec3 c2 = vec3( a( ivec4( ic2, 0 ) ), a( ivec4( ic2, 1 ) ), a( ivec4( ic2, 2 ) ) );
vec3 c3 = vec3( a( ivec4( ic3, 0 ) ), a( ivec4( ic3, 1 ) ), a( ivec4( ic3, 2 ) ) );
vec3 c4 = vec3( a( ivec4( ic4, 0 ) ), a( ivec4( ic4, 1 ) ), a( ivec4( ic4, 2 ) ) );
vec3 c5 = vec3( a( ivec4( ic5, 0 ) ), a( ivec4( ic5, 1 ) ), a( ivec4( ic5, 2 ) ) );
vec3 c6 = vec3( a( ivec4( ic6, 0 ) ), a( ivec4( ic6, 1 ) ), a( ivec4( ic6, 2 ) ) );
vec3 c7 = vec3( a( ivec4( ic7, 0 ) ), a( ivec4( ic7, 1 ) ), a( ivec4( ic7, 2 ) ) );
vec3 c8 = vec3( a( ivec4( ic8, 0 ) ), a( ivec4( ic8, 1 ) ), a( ivec4( ic8, 2 ) ) );
float fc1 = dot( c1, f - vec3( 0, 0, 0 ) );
float fc2 = dot( c2, f - vec3( 1, 0, 0 ) );
float fc3 = dot( c3, f - vec3( 0, 1, 0 ) );
float fc4 = dot( c4, f - vec3( 1, 1, 0 ) );
float fc5 = dot( c5, f - vec3( 0, 0, 1 ) );
float fc6 = dot( c6, f - vec3( 1, 0, 1 ) );
float fc7 = dot( c7, f - vec3( 0, 1, 1 ) );
float fc8 = dot( c8, f - vec3( 1, 1, 1 ) );
float u = fade( f.x );
float v = fade( f.y );
float w = fade( f.z );
float v1 = mix( fc1, fc2, u );
float v2 = mix( fc3, fc4, u );
float v3 = mix( fc5, fc6, u );
float v4 = mix( fc7, fc8, u );
float v5 = mix( v1, v2, v );
float v6 = mix( v3, v4, v );
float v7 = mix( v5, v6, w );
ret[ 0 ] = cat_amp * ( v7 * 0.5 + 0.5 );
' 1 1 0 0;
return;





////////////////////////////////////////////////////////////////////////////////
// fractalNoise3d
// This function takes 2 arguments, initial grid size, and texture size and
// returns a tensor with multiple combined octaves of perlin noise.

l'fractalNoise3d';
fngradsize=;
fntexsize=;
[0.5];fnamp=;
[1];fnseed=;

fngradsize;fntexsize;fnamp;fnseed;perlin3d;

l'fnloop3d';
fngradsize;[2 2 2];*;fngradsize=;
fnamp;[0.5];*;fnamp=;
fnseed;[1.2];+;fnseed=;
fngradsize;fntexsize;fnamp;fnseed;perlin3d;
6;fntexsize;c''''ret[0]=a(t)+b(t);' 2 1 0 0;
fntexsize;fngradsize;/;first;4;==;ifn'fnloop3d';
return;






l'stdlibend';
// the console goes at the top, so it can circumvent the script, but after stdlib, so we can have input and textblit.
include'inc\catcon.atl';
