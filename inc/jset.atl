include'inc\stdlib.atl';
'main.atl';
include'inc\nav.atl';

size;if'started'; // init code goes here
nav4d;
[0 0 3 0];set'fourOrigin' 4;
4;set'speed';

1; // dummy value to pop off in place of display tensor.
l'started'; // init code complete

pop; // Pop the last display tensor off the stack.

nav4d;[0 0.1];set'navp' 2;

6;windowSize;[2 2];/;0;dup;set'wdims' 2;
get'wdims';0;dup;first;1;dup;last;/;0.5;^;e;set'aspect' 1;pop;

////////////////////////////////////////////////////////////////////////////////
// GLSL Functions
////////////////////////////////////////////////////////////////////////////////
c'''
const float MAX_ITERS = 128.0\
//const float MAX_STEPS = 64.0\
const float SCALE_FACTOR = 0.0625\
const float MAX_DIST = 0.5\
const float MIN_DIST = 1.0 / (MAX_ITERS - 1.0)\
const float LESS_THAN_MIN_DIST = 1.0 / float(MAX_ITERS)\
const int MAX_DEPTH = 2\
const float INIT_DIST = 6.0\

float julia(vec4 p) {
    vec2 z = p.xy\
    vec2 c = p.zw\

    const float bailout = 4.0\
    float iter = 0.0\
    for (float i = 0.0\ i < MAX_ITERS\ i++) {
        // z_{n+1} = z_n^2 + c
        z = vec2(
            z.x * z.x - z.y * z.y,
            2.0 * z.x * z.y
        ) + c\

        if (dot(z, z) > bailout)
            return max(1.0,iter + max(0.0,log(log(dot(z,z)))))\
        ++iter\
    }

    return MAX_ITERS\
}

float raymarch(vec4 ro, vec4 rd, float maxt) {
  float searchMin = 0.0\
  float searchMax = maxt\
  float maxIter = 0.0\
  float maxT = 0.0\
  
  for(int depth = 0\ depth < MAX_DEPTH\ ++depth) {
    float range = searchMax - searchMin\
    maxIter = 0.0\
    float iter = 100000000000000000000000000.000\
    for(float t = searchMin\ t <= searchMax\ t += range * 0.05 / iter ) {
      vec4 p = ro + rd * t\ 
      iter = julia(p)\
      
      if(iter > maxIter) {
        maxIter = iter\
        maxT = t\
      }
      if(maxIter >= MAX_ITERS) break\
    }
    
    float window = range * SCALE_FACTOR\
    searchMin = max(0.0, maxT - window)\
    searchMax = min(maxt, maxT + window)\
  }
  
  if(maxIter >= MAX_ITERS) return maxT\
  return -1.0\
}

// Normal estimation in 4D
vec4 calcNormal(vec4 p) {
  vec2 e = vec2(0.005, 0.0)\
  return normalize(vec4(
    julia(p + e.xyyy) - julia(p - e.xyyy),
    julia(p + e.yxyy) - julia(p - e.yxyy),
    julia(p + e.yyxy) - julia(p - e.yyxy),
    julia(p + e.yyyx) - julia(p - e.yyyx)
  ))\
}

////////////////////////////////////////////////////////////////////////////////
// The shader
////////////////////////////////////////////////////////////////////////////////

'
// Compute the initial ray in view space
vec4 ray = normalize(
    vec4(
      ( tf.xy / wdims * 2.0 - 1.0 ) * vec2(aspect, 1.0/aspect), 
      -1.0, 0.0
    )
)\

// Rotate ray by camera rotation
vec4 rd = worldRotation * ray\

float result = raymarch( fourOrigin, rd, INIT_DIST)\
vec4 p4 = fourOrigin + rd * result\
vec3 p = p4.xyz\  // For display, project to 3D

vec3 color = vec3(0.1, -1.0, 0.2)\  // Background

if(result > 0.0) {
  // Hit!
  vec4 n4 = calcNormal(p4)\  // Pass vec4, get vec4 back
  vec3 n = normalize(n4.xyz)\  // Project to 3D for lighting
  
  // Simple lighting
  vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0))\
  float diff = max(dot(n, lightDir), 0.0)\
  
  // Color based on position in b-axis
  float height = (p.z + 1.0) * 0.5\  // Map [-1,1] to [0,1]
  color = vec3(height, 0.5, 1.0 - height) * (0.3 + 0.7 * diff)\
  color = vec3(0.0,result,0.0)\
}

ret[0] = color.g\
'
0 1 0;

6;get'wdims';[4];0;cat;
c''''
const float epsilon = 0.05\
ivec4 center = ivec4(tf,0,0)\
const ivec4 offsets[12] = ivec4[12](
    ivec4(1, 0, 0, 0),
    ivec4(0, 1, 0, 0),
    ivec4(-1, 0, 0, 0),
    ivec4(0, -1, 0, 0),
    ivec4(2, 0, 0, 0),
    ivec4(0, 2, 0, 0),
    ivec4(-2, 0, 0, 0),
    ivec4(0, -2, 0, 0),
    ivec4(1, 1, 0, 0),
    ivec4(1, -1, 0, 0),
    ivec4(-1, 1, 0, 0),
    ivec4(-1, -1, 0, 0)    
)\
const float weights[12] = float[12](
      1.0, 1.0, 1.0, 1.0, 
      0.5, 0.5, 0.5, 0.5,
      0.707, 0.707, 0.707, 0.707
)\
float coverage = 0.0\
float centersample = a(center)\
for(int i = 0\i < 12\++i){
  ivec4 ns = clamp(center+offsets[i],ivec4(0,0,0,0),ivec4(wdims,0,0))\
  float dif = clamp((a(ns)-centersample)/epsilon,-1.0,1.0)\
  coverage += weights[i] * dif / 12.0\
}



ret[0] = vec4(0.0,1.0-coverage,0.0,1.0)\
' 1 1 4;

//////////////////////////////////////////////////////////////////
// Help and framerate

get'keys';[58 59 0];s;first;ifn'skipf1';
'Click and drag: rotate view                ';e;
'Right click: fly forward                   ';e;0;cat;
'w/s/a/d/c/shift/ctrl/space/q/e: fly around ';e;0;cat;
'Mouse wheel: change fly speed              ';e;0;cat;
'z/x: translate through 4d                  ';e;0;cat;
't/g: rotate through the zw plane           ';e;0;cat;
'f: switch mouse rotation mode between 3d/4d';e;0;cat;
textToTexture;blitText;
l'skipf1';
get'keys';[59 60 0];s;first;get'gamepad';[13 14 0];s;first;+;ifn'skipf2';
1;timeDelta;/;toString;e;
textToTexture;blitText;
l'skipf2';
