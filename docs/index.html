<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Document revised for mobile-friendliness -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Atlas Language Reference</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      display: flex;
      flex-direction: row;
      background: #1e1e1e;
      color: #ddd;
    }

    /* Sidebar (Table of Contents) */
    nav {
      width: 300px;
      padding: 1em;
      border-right: 1px solid #444;
      background: #232323;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100vh;
      position: sticky;
      top: 0;
    }

    nav h2 {
      margin-top: 0;
      color: #ddd;
    }

    nav details summary {
      font-weight: bold;
      cursor: pointer;
      outline: none;
      color: #ddd;
    }

    nav ul {
      margin: 0.5em 0 1em 1.5em;
      padding-left: 0;
      list-style-type: disc;
      color: #ccc;
    }

    nav a {
      text-decoration: none;
      color: #4da6ff;
    }

    nav a:hover {
      text-decoration: underline;
    }

    /* Main content area */
    main {
      flex: 1;
      padding: 2em;
      box-sizing: border-box;
      background: #1e1e1e;
      /* min-width: 0 prevents unwanted horizontal scroll in flex layouts */
      min-width: 0;
    }

    main section h1,
    main section h2,
    main section h3 {
      margin-top: 2em;
      border-bottom: 1px solid #444;
      padding-bottom: 0.25em;
      color: #eee;
    }

    /* Inline code */
    code {
      background: #333;
      padding: 0.1em 0.3em;
      line-height: 1.0;
      border-radius: 3px;
      color: #eee;
    }

    /**
     * CODE BLOCKS:
     * Give <pre> a background and horizontal scroll so the box extends fully
     * while scrolling sideways.
     */
    pre {
      margin: 1em 0;
      overflow-x: auto;      /* enable horizontal scroll if needed */
      background: #333;      /* ensure background extends under scrollbar */
      border-radius: 3px;
    }
    pre code {
      /* Inherit the pre’s background so the box is seamless. */
      display: block;
      padding: 1em;
      background: transparent;
      white-space: pre;      /* keep code formatting intact */
      word-wrap: normal;     /* do not wrap code text */
      color: #eee;
    }

    /* Make images responsive by default */
    img {
      max-width: 100%;
      height: auto;
    }

    .logo-container {
      display: flex;
      align-items: center;
      padding: 1em;	  
      font-size: 80%;
    }
    .logo-container img {
      /* Let it shrink or grow nicely; use a fixed max-width if you want to cap it. */
      width: 150px;
      padding-right: 1em;
      height: auto;
      display: block;
    }

    /* Smooth scroll behavior */
    html {
      scroll-behavior: smooth;
      }

    /* --- Responsive layout for smaller screens --- */
    @media (max-width: 800px) {
      body {
        flex-direction: column;
      }

      nav {
        width: 100%;
        height: auto;
        position: static;
        border-right: none;
        border-bottom: 1px solid #444;
      }

      main {
        width: 100%;
        padding: 1em;
      }
    }
  </style>
</head>
<body>

<nav>
  <h2>Table of Contents</h2>
  <details>
    <summary>Overview</summary>
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#audience">Audience</a></li>
      <li><a href="#basic-concepts">Basic Concepts</a></li>
      <li><a href="#program-model">Program Model</a></li>
      <li><a href="#invocation">Invocation</a></li>
    </ul>
  </details>

  <details>
    <summary>Language Outline</summary>
    <ul>
      <li><a href="#data-types">Data Types</a></li>
      <li><a href="#tensors">Tensors</a></li>
      <li><a href="#variables">Variables</a></li>
      <li><a href="#control-structures">Control Structures</a></li>
      <li><a href="#functions">Functions</a></li>
      <li><a href="#looping">Looping</a></li>
    </ul>
  </details>

  <details>
    <summary>Examples</summary>
    <ul>
      <li><a href="#demos">Demos</a></li>
      <li><a href="#example-1">Fibonacci Sequence</a></li>
      <li><a href="#example-2">Simple Gradient</a></li>
    </ul>
  </details>
  
  <details open>
    <summary>Commands Reference</summary>
    <ul>
      <li><a href="#cmd-additive">additive</a></li>
      <li><a href="#cmd-arith">+ / - / * / / / ^ (arithmetic)</a></li>
      <li><a href="#cmd-c">c (compute)</a></li>
      <li><a href="#cmd-cat">cat (concatenate)</a></li>
      <li><a href="#cmd-depth">depth</a></li>
      <li><a href="#cmd-dup">dup (duplicate)</a></li>
      <li><a href="#cmd-enclose">e (enclose)</a></li>
      <li><a href="#cmd-extrude">ext (extrude)</a></li>
      <li><a href="#cmd-first">first / last</a></li>
      <li><a href="#cmd-gamepad">gamepad</a></li>
      <li><a href="#cmd-get">get</a></li>
      <li><a href="#cmd-if">if / ifn</a></li>
      <li><a href="#cmd-img">img (image)</a></li>
      <li><a href="#cmd-include">include</a></li>
      <li><a href="#cmd-input">input</a></li>
      <li><a href="#cmd-keys">keys</a></li>
      <li><a href="#cmd-l">l (length)</a></li>
      <li><a href="#cmd-load">load</a></li>
      <li><a href="#cmd-m">m (matrix multiply)</li>
      <li><a href="#cmd-pop">pop</a></li>
      <li><a href="#cmd-projection">proj (projection)</a></li>
      <li><a href="#cmd-print">print</a></li>
      <li><a href="#cmd-quit">quit</a></li>
      <li><a href="#cmd-r">r (reverse)</a></li>
      <li><a href="#cmd-repeat">rep (repeat)</a></li>
      <li><a href="#cmd-return">return</a></li>
      <li><a href="#cmd-rotate">rot (rotate)</a></li>
      <li><a href="#cmd-rtd">rtd (render to desktop)</a></li>
      <li><a href="#cmd-s">s (slice)</a></li>
      <li><a href="#cmd-set">set</a></li>
      <li><a href="#cmd-shape">shape</a></li>
      <li><a href="#cmd-size">size</a></li>
      <li><a href="#cmd-t">t (transpose)</a></li>
      <li><a href="#cmd-texture">texture</a></li>
      <li><a href="#cmd-timeDelta">timeDelta</a></li>
      <li><a href="#cmd-toString">toString</a></li>
      <li><a href="#cmd-translate">translate</a></li>
      <li><a href="#cmd-unext">unext (unextrude)</a></li>
      <li><a href="#cmd-while">while / for</a></li>
      <li><a href="#cmd-windowSize">windowSize</a></li>
    </ul>
  </details>
</nav>

<main>
  <!-- New .logo-container so the image + title layout more nicely. -->
  <div class="logo-container">
    <img src="logo.png" alt="Atlas Logo">  
    <h1 style="margin: 0; font-size: 5em; font-weight: bold; font-family: serif;">Atlas</h1>
  </div>

  <section id="introduction">
    <h2>Introduction</h2>
    <p>This document describes the syntax and semantics of the <em><a href="Atlas.html">Atlas</a></em> programming language. 
      Atlas is a real-time visualization language focusing on ease of GPU utilization. The paradigm used by
      Atlas is a stack of tensors. This offers advantages relating to memory management, making
      copying, slicing, reversing, and transposing all constant time operations. The workhorse of Atlas is 
      the <code>c</code>(compute) statements, which allow the definition of arbitrary GLSL functions, multiple return values, 
      and parameters of different sizes. Compute statements always compute on the accelerator, and 
      consequently should be restricted to large tensors.</p>
  </section>

  <section id="audience">
    <h2>Audience</h2>
    <p>In order for Atlas to be useful to you, you will need to know GLSL well. There are many tutorials 
      available online, and some examples in this document. Atlas is ideal for testing out new GPU algorithms quickly. This is its main use case.</p>
  </section>

  <section id="basic-concepts">
    <h2>Basic Concepts</h2>
    <p>Atlas code is stack-oriented and uses a simple command-oriented syntax. Comments start with <code>//</code> 
      and extend to the end of the line. Whitespace and indentation are primarily for readability and do not 
      affect the program’s semantics. All commands are terminated with semicolons (<code>;</code>).
      Labels are declared with <code>l</code> and quotes such as <code>l'aLabel'</code>. The core point of this 
      language is to make it easier to program the GPU. Most commands consume their arguments; for example 
      the sequence <code>1;if'go';</code> would push a 1 onto the stack, and then immediately consume it as a 
      truth value and branch to the label 'go'.</p>
    <p>Atlas runs natively on Windows 10 and 11, and also on the web using emscripten. Porting to Linux 
      is unlikely without third party help, but shouldn't be too hard in principle.</p>
  </section>

  <section id="program-model">
    <h2>Program Model</h2>
    <p>The program model used by Atlas is a loop. At the end of the program running, the tensor on top of 
      the stack is used as the RGB 3-channel display tensor, filling the window with that tensor, and then 
      the program restarts from the beginning. The examples and documentation below will make this clearer.</p>
  </section>      

  <section id="invocation">
    <h2>Invocation</h2>
    <p>Atlas takes one parameter as an argument: the file to be run.  If not given a filename, Atlas will run "main.atl" if present, or print a brief usage message if not.  To invoke through a browser copy Atlas.html, Atlas.js, Atlas.wasm and Atlas.data to a served directory. A file named filelist.txt must also be present in the directory, which is a list of files to preload onto the filesystem.  The list will include a main.atl and any supporting files. See the docs directory for a concrete example.</p>
  </section>      

  <hr>

  <section id="data-types">
    <h2>Data Types</h2>
    <p>All data in Atlas is floating point. This means that linear indexing only works out to about 16 million
      (24 bits), and the effective maximum dimension size (but not total size) of a tensor is 16 million. The total number of elements may not exceed 2^32 (4 gigaelements) or adressing will fail. All other types of data 
      (e.g. strings) are converted into a tensor of floating point values.</p>
    <ul>
      <li><strong>Number:</strong> Integers and floats, scalars are tensors too (e.g., <code>42</code>, <code>3.14</code>).</li>
      <li><strong>String:</strong> Text codepoints in single quotes (e.g., <code>'Hello'</code>).</li>
      <li><strong>Image:</strong> Bitmaps may be loaded with the <code>load'image.bmp'</code> command.</li>
      <li><strong>Tensor:</strong> A multi-dimensional array used for advanced data manipulation (e.g. <code>[[1 2] [3 4]]</code> 
        or <code>[1.0 2.0]</code> or just <code>0.0</code>).</li>
    </ul>
  </section>

  <section id="tensors">
    <h2>Tensors</h2>
    <p>Tensors are central to Atlas, as they are the only data structure built into the language. 
      A tensor is a generalized multi-dimensional array. For example, a vector is a 1D tensor, a matrix is 
      a 2D tensor, and dimensions up to 4 are also supported.</p>
  </section>

  <section id="variables">
    <h2>Variables</h2>
    <p>Variables are set with a <code>set</code> command like <code>set'varName' 2</code> with <code>varName</code> a valid GLSL 
      identifier. Variables set this way will be available as uniforms in shaders, as well as through 
      <code>get'varName'</code> commands.</p>
  </section>

  <section id="control-structures">
    <h2>Control Structures</h2>
    <p>Atlas uses labels and <code>if</code> statements for control flow. These two structures alone are sufficient 
      to reconstruct the rest. For example <code>1;if'label';</code> does an unconditional branch to <code>l'label'</code> 
      located elsewhere in the code.</p>
  </section>

  <section id="functions">
    <h2>Functions</h2>
    <p>Functions are just labels in Atlas followed by a return command. For example, to add the top two 
      elements on the stack:</p>
    <pre><code>l'add'; // Add the top two tensors element-wise
+;
return;
</code></pre>
    <p>and then later in the code this function is called by name with just <code>add</code>.</p>
  </section>

  <section id="looping">
    <h2>Looping</h2>
    <p>Atlas programs are run in a loop, once per each frame of animation. Consequently, your program 
      should be designed to pass through rather than block. To quit the program, you can manually call 
      <code>quit</code>. At the end of each loop, a 4 channel rank 3  tensor must be on top of the stack, this
      is used as the image to display.</p>
  </section>

  <hr>

  <section id="demos">
    <h2>Demos</h2>
    <p>A set of more full fledged demos can be seen in the distributed main.atl <a href="Atlas.html">here</a>.</p>
  </section>

  <section id="example-1">
    <h2>Fibonacci Sequence</h2>
    <p>
      <pre><code>0;1; // Push the first two elements of the sequence.
l'fib';1;dup;1;dup;+; // Duplicate the top two elements and then add them.
0;dup;21;-;if'fib'; // Loop back to l'fib' if the top of the stack isn't 21.
print;quit; // Show the results.</code></pre>
      prints
      <pre><code>Tensor 8
Shape:
Strides:
21.00

Tensor 7
Shape:
Strides:
13.00

Tensor 6
Shape:
Strides:
8.00

Tensor 5
Shape:
Strides:
5.00

Tensor 4
Shape:
Strides:
3.00

Tensor 3
Shape:
Strides:
2.00

Tensor 2
Shape:
Strides:
1.00

Tensor 1
Shape:
Strides:
1.00

Tensor 0
Shape:
Strides:
0.00</code></pre>
    </p>
  </section>

  <section id="example-2">
    <h2>Simple Gradient</h2>
    <p>
      <pre><code>size;if'skip'; // Skip if we've already created the gradient.
6;[16 16 3];c''''ret[0]=i / 767.0\' 0 1 0; // The linear index goes to 16*16*3 - 1 = 767.0.
l'skip';
</code></pre>
      will display
      <pre><code><img src="gradient.png" alt="gradient example"></code></pre>
    </p>
  </section>

  <hr>

  <section id="cmd-additive">
    <h2>additive</h2>
    <p>This command makes it so that subsequent c compute commands are done in additive mode.  Additive mode means that
 if two triangle coincide, they both draw, and add together the results.</p>
  </section>

  <section id="cmd-arith">
    <h2>+ / - / * / / / ^</h2>
    <p>These arithmetic commands take two arguments and do one of add, subtract, multiply, divide or exponentiate them, respectively.  The argument on the top of the stack is the subtractend, denominator, or exponent, while the tensor below is the minuend, numerator, or base.  These operations are done on the CPU and therefore should only be done on small tensors.  Large tensor computation should be done with the c (compute) command. For example: 
    <pre><code>[1 2 3];[0.5 4 0.1];*;print;quit;</code></pre>will print
    <pre><code>Tensor 0
Shape: 3
Strides: 1
+----------------+
| 0.50 8.00 0.30 |
+----------------+</code></pre></p>

  </section>

  <section id="cmd-c">
    <h2>c (compute)</h2>
c (compute)

The c command is the core compute operation in Atlas. It lets you execute custom GLSL code on the GPU to produce an output tensor (or texture) from one or more input tensors. In short, everything else in Atlas is built around making it easier to perform GPU computations using this command.
Syntax
<pre><code>c'vertexShaderFuncs'optionalVertexShader'glslFuncs'glslExpression' argCount retCount channels</code></pre>

Before calling c, you must have pushed the following onto the stack (in order):

    Output Shape: A tensor that defines the shape of the output.
    Vertex Count: An integer specifying the vertex count (for example, 6 for two triangles when no custom vertex shader is provided).
    Input Tensors (optional): Up to four tensors that will serve as inputs to your shader.

<h3>Quoted String Parameters</h3>

After the c command, there are several quoted strings that contain your shader code and declarations:

    vertexShaderFuncs:
    A string for declaring functions or variables used in the vertex shader. (For example, you can use this to declare output variables that the fragment shader will later read.)

    optionalVertexShader:
    An optional string that contains the actual vertex shader code. If omitted, a default vertex shader is used.

    glslFuncs:
    A string where you can declare additional GLSL functions, constants, or helper code.
    Note: Semicolons are not allowed in any of these shader strings. Instead, terminate each statement with a backslash (\).

    glslExpression:
    This string contains the main shader code (similar to a fragment shader). Here you must assign values to the output array elements (ret[0] to ret[retCount - 1]). These assignments determine the output tensors.

Within the shader code (especially in glslExpression), you have access to the following indices:

    i: A linear (integer) index.
    t: An ivec4 representing the multidimensional tensor index.
    ifloat and tf: Floating-point versions of i and t.

<h3>Numeric Parameters</h3>

Following the quoted strings, you supply three numeric parameters:

    argCount:
    A number between 0 and 4 that tells Atlas how many input tensors (from the stack) to provide to the shader. These tensors are available as functions named a, b, c, and d. Each such function accepts an ivec4 index and returns the corresponding tensor element.

    retCount:
    The number of output values your shader produces. Your glslExpression must assign a value to each of ret[0] through ret[retCount - 1].

    channels:
    This parameter determines the output mode:
        Tensor Mode (channels = 0):
        The shader produces one or more tensors as output.
        Texture Mode (channels = 4):
        A 4-channel texture is created instead of a tensor. In texture mode, the texture can only be used by subsequent c commands through specialized texture sampling functions (af, bf, cf, and df) that take vec2 UV coordinates. (Also note that operations which modify tensor shape—like reverse or transpose—won’t work on textures.)
        The type of the returned data will automatically be set to float, vec2, vec3, or vec4 depending on whether you use 1, 2, 3, or 4 channels.

<h3>Important Notes</h3>

    Statement Termination:
    In all shader code strings (i.e., glslFuncs and glslExpression), you cannot use semicolons (;). Instead, end each statement with a backslash (\).

    Input Tensor Access:
    When you specify an argCount greater than zero, each of the top input tensors is made available inside your shader as a function (a, b, c, or d). These functions take an ivec4 argument (the index within the tensor) and return the corresponding value.

    Operation Modes:
        Tensor mode (when channels is 0) is the standard mode where the shader outputs a tensor.
        Texture mode (when channels is 4) creates a 4-channel texture with some limitations regarding how it can be used later in your program.

<h3>Example</h3>

The following Atlas snippet uses two input tensors to compute element‐wise minimum and maximum values. The shader compares the corresponding elements from the two input tensors and writes the minimum to one output tensor and the maximum to another:

<pre><code>
[[1 2][3 4]];[[2 1][5 3]];   // Push two tensors onto the stack.
6;[2 2];                     // Push the output shape (vertex count is 6 for two triangles).
c''''                       // Call compute with empty vertexShaderFuncs, optionalVertexShader, and glslFuncs.
ret[0] = a(t) < b(t) ? a(t) : b(t)\  // For each element: output the minimum into ret[0].
ret[1] = a(t) < b(t) ? b(t) : a(t)\  // And output the maximum into ret[1].
' 2 2 0;                    // Numeric arguments: argCount = 2, retCount = 2, channels = 0 (tensor mode).
print;quit;
</code></pre>

After execution, the first output tensor (from ret[0]) will contain the element-wise minimum values, and the second (from ret[1]) will contain the element-wise maximum values.

    <p>This will print:</p>
    <pre><code>Tensor 1
Shape: 2 2
Strides: 2 1
+---------------+
| +-----------+ |
| | 1.00 1.00 | |
| +-----------+ |
| +-----------+ |
| | 3.00 3.00 | |
| +-----------+ |
+---------------+

Tensor 0
Shape: 2 2
Strides: 2 1
+---------------+
| +-----------+ |
| | 2.00 2.00 | |
| +-----------+ |
| +-----------+ |
| | 5.00 4.00 | |
| +-----------+ |
+---------------+
</code></pre>
  </section>

  <section id="cmd-cat">
    <h2>cat (concatenate)</h2>
    <p>Given a stack of <code>t1</code>, <code>t2</code>, and <code>axis</code> (a scalar), the command concatenates <code>t2</code> onto <code>t1</code> along axis <code>axis</code>. For example:
      <pre><code>[[0 1][2 3]];[[4 5][6 7]];0;cat;
[[0 1][2 3]];[[4 5][6 7]];1;cat;
print;quit;</code></pre> 
      prints 
      <pre><code>Tensor 1
Shape: 2 4
Strides: 4 1
+-------------------------+
| +---------------------+ |
| | 0.00 1.00 4.00 5.00 | |
| +---------------------+ |
| +---------------------+ |
| | 2.00 3.00 6.00 7.00 | |
| +---------------------+ |
+-------------------------+

Tensor 0
Shape: 4 2
Strides: 2 1
+---------------+
| +-----------+ |
| | 0.00 1.00 | |
| +-----------+ |
| +-----------+ |
| | 2.00 3.00 | |
| +-----------+ |
| +-----------+ |
| | 4.00 5.00 | |
| +-----------+ |
| +-----------+ |
| | 6.00 7.00 | |
| +-----------+ |
+---------------+</code></pre>
    </p>
  </section>

  <section id="cmd-depth">
    <h2>depth</h2>
    <p>This command toggles depth testing (32-bit).</p>
  </section>

  <section id="cmd-dup">
    <h2>dup (duplicate)</h2>
    <p>Given a scalar integer N on top of the stack, duplicates the Nth item on the stack and places it on top. For example:
    <pre><code>[0 1 2];0;dup;print;quit;</code></pre> 
    prints 
    <pre><code>Tensor 1
Shape: 3
Strides: 1
+----------------+
| 0.00 1.00 2.00 |
+----------------+

Tensor 0
Shape: 3
Strides: 1
+----------------+
| 0.00 1.00 2.00 |
+----------------+</code></pre>
    </p>
  </section>

  <section id="cmd-enclose">
    <h2>e (enclose)</h2>
    <p>This takes the tensor on top of the stack and raises its rank by 1 appending [1] onto its shape. For example:
      <pre><code>.5;e;[[0 1][2 3]];e;print;quit;</code></pre> 
      prints 
      <pre><code>Tensor 1
Shape: 1 2 2
Strides: 2 2 1
+---------------------------------+
| +-----------------------------+ |
| | +-----------+ +-----------+ | |
| | | 0.00 1.00 | | 2.00 3.00 | | |
| | +-----------+ +-----------+ | |
| +-----------------------------+ |
+---------------------------------+

Tensor 0
Shape: 1
Strides: 1
+------+
| 0.50 |
+------+</code></pre>
    </p>
  </section>

  <section id="cmd-extrude">
    <h2>ext (extrude)</h2>
    <p>This takes the tensor on top of the stack and raises its rank by 1 prepending [1] onto its shape. For example:
      <pre><code>.5;ext;[[0 1][2 3]];ext;print;quit;</code></pre> 
      prints 
      <pre><code>Tensor 1
Shape: 2 2 1
Strides: 2 1 1
+-----------------------+
| +-------------------+ |
| | +------+ +------+ | |
| | | 0.00 | | 1.00 | | |
| | +------+ +------+ | |
| +-------------------+ |
| +-------------------+ |
| | +------+ +------+ | |
| | | 2.00 | | 3.00 | | |
| | +------+ +------+ | |
| +-------------------+ |
+-----------------------+

Tensor 0
Shape: 1
Strides: 1
+------+
| 0.50 |
+------+</code></pre>
    </p>
  </section>

  <section id="cmd-first">
    <h2>first / last</h2>
    <p>These commands return the first or last element along the first axis, reducing rank by 1. For example:
      <pre><code>[[0 1][2 3]];first;print;last;print;quit;</code></pre>
      prints 
      <pre><code>Tensor 0
Shape: 2
Strides: 1
+-----------+
| 0.00 1.00 |
+-----------+

Tensor 0
Shape:
Strides:
1.00</code></pre>
    </p>
  </section>

  <section id="cmd-gamepad">
    <h2>gamepad</h2>
    <p>This command pushes a vector of vectors corresponding to the gamepad state of attached controllers.
    The returned vectors are of the form [throttleLeft throttleRight leftStickX leftStickY rightStickX rightStickY leftShoulder rightShoulder home up right down left select start a b x y leftStick rightStick]</p>
  </section>

  <section id="cmd-get">
    <h2>get</h2>
    <p>Gets a named variable and pushes it onto the stack as a tensor. For example 
      <pre><code>get'vec';</code></pre>
      would get a variable named <code>vec</code> and push it onto the stack.</p>
  </section>

  <section id="cmd-if">
    <h2>if / ifn</h2>
    <p>The two if and ifn commands implement conditional branching:
      <pre><code>get'bool';first;if'jump'; // This branches to the label l'jump' if 'bool' is positive.
0;ifn'jump'; // This unconditionally jumps to l'jump' because a 0 was pushed on the stack and ifn branches on zero.
</code></pre>
      Looks at the top of the stack, and jumps to the label 'jump' if it is/isn't positive. The top of 
      the stack must be a scalar and is consumed by the <code>if</code>/<code>ifn</code> command.</p>
  </section>

  <section id="cmd-img">
    <h2>img (image)</h2>
    <p>Loads a 4-channel bitmap from a file. For example:
      <pre><code>img'font.bmp'</code></pre>
      loads <code>font.bmp</code> as a <code>[width height 4]</code> tensor.</p>
  </section>

  <section id="cmd-include">
    <h2>include</h2>
    <p>This includes another file textually, placing all the commands in that file at the location of the include command. For example <code>include'head.atl'</code> would include all the commands of <code>head.atl</code>.</p>
  </section>

  <section id="cmd-input">
    <h2>input</h2>
    <p>This loads a 6 element input tensor corresponding to the mouse cursor. The first two elements are the x and y mouse deltas, and the 3rd element is the mouse wheel delta. The next 3 elements correspond to the left, right, and middle mouse buttons, 1.0 if held, 0.0 if released, and 2.0 if double clicked.</p>
  </section>

  <section id="cmd-keys">
    <h2>keys</h2>
    <p>This command loads a [512] shaped tensor corresponding to keyboard presses.  The array will have a 1 if the corresponding key is being pressed, and 0 if not. For example:
      <pre><code>keys;[41 42 0];s;first;ifn'go';quit;l'go';</code></pre> 
      will exit if esc (SDL_Scancode 41) is pressed.  
      <a href="https://wiki.libsdl.org/SDL2/SDL_Scancode" style="color:#4da6ff;">See SDL_Scancode docs</a>.</p>
  </section>

  <section id="cmd-l">
    <h2>l (length)</h2>
    <p>This command takes a tensor of rank 1, a vector, and pushes the Euclidean distance of it onto the stack.</p>
  </section>

  <section id="cmd-load">
    <h2>load</h2>
    <p>Loads another Atlas file, resets the stack, and starts executing it. For example: <code>load'mandelbrot.atl'</code>.  If called without quotes, it treats the top of the stack (which must be a vector) as the filename.</p>
  </section>

  <section id="cmd-m">
    <h2>m (matrix multiply)</h2>
    <p>This mulitplies the top two tensors (which must be rank 2 or less) and pushes the result on the stack. The result is always of rank 2. For example <code>[[1 0 1][2 1 1][0 1 1][1 1 2]];[[1 2 1][2 3 1][4 2 2]];m;print;quit;</code> prints <pre><code>Tensor 0
Shape: 4 3
Strides: 3 1
+-----------------------+
| +-------------------+ |
| | 5.00  4.00  3.00  | |
| +-------------------+ |
| +-------------------+ |
| | 8.00  9.00  5.00  | |
| +-------------------+ |
| +-------------------+ |
| | 6.00  5.00  3.00  | |
| +-------------------+ |
| +-------------------+ |
| | 11.00 9.00  6.00  | |
| +-------------------+ |
+-----------------------+</code></pre> and <code>[[5 4 3][8 9 5][6 5 3][11 9 6]];[100 80 60];m;print;quit;</code> will print <pre><code>Tensor 0
Shape: 4 1
Strides: 1 1
+-------------+
| +---------+ |
| | 1000.00 | |
| +---------+ |
| +---------+ |
| | 1820.00 | |
| +---------+ |
| +---------+ |
| | 1180.00 | |
| +---------+ |
| +---------+ |
| | 2180.00 | |
| +---------+ |
+-------------+</code></pre> The m command can also be used as a dot product; <code>[1 2];[3 4];m;print;quit;</code> will print <pre><code>Tensor 0
Shape: 1 1
Strides: 1 1
+-----------+
| +-------+ |
| | 11.00 | |
| +-------+ |
+-----------+</code></pre> </p>
  </section>

  <section id="cmd-pop">
    <h2>pop</h2>
    <p>Pops the stack, resulting in a fatal error if it was empty.</p>
  </section>

  <section id="cmd-projection">
    <h2>proj (projection)</h2>
    <p>This takes a 5-vector argument in the form <code>[fov width height near far]</code> and pushes a corresponding projection matrix onto the stack.</p>
  </section>

  <section id="cmd-print">
    <h2>print</h2>
    <p>Prints the stack.</p>
    <pre><code>[1 2 .3];'Hello, world!';print;</code></pre>
    <p>results in</p>
    <pre><code>Tensor 1
Shape: 13
Strides: 1
+--------------------------------------------------------------------------------------------+
| 72.00  101.00 108.00 108.00 111.00 44.00  32.00  119.00 111.00 114.00 108.00 100.00 33.00  |
+--------------------------------------------------------------------------------------------+

Tensor 0
Shape: 3
Strides: 1
+----------------+
| 1.00 2.00 0.30 |
+----------------+
</code></pre>
  </section>

  <section id="cmd-quit">
    <h2>quit</h2>
    <p>Quits the program.</p>
  </section>

  <section id="cmd-r">
    <h2>r (reverse)</h2>
    <p>Reverses a tensor along a specified dimension (axis). The axis, a scalar, should be on top of 
      the stack, and the tensor below that. This is equivalent to mirroring along an axis. For example:
      <pre><code>[[0 1][2 3]];0;r;print;quit;</code></pre>
      prints
      <pre><code>Tensor 0
Shape: 2 2
Strides: -2 1
+---------------+
| +-----------+ |
| | 2.00 3.00 | |
| +-----------+ |
| +-----------+ |
| | 0.00 1.00 | |
| +-----------+ |
+---------------+
</code></pre>
      and
      <pre><code>[[0 1][2 3]];1;r;print;quit;</code></pre>
      prints
      <pre><code>Tensor 0
Shape: 2 2
Strides: 2 -1
+---------------+
| +-----------+ |
| | 1.00 0.00 | |
| +-----------+ |
| +-----------+ |
| | 3.00 2.00 | |
| +-----------+ |
+---------------+
</code></pre></p>
  </section>
  
  <section id="cmd-repeat">
    <h2>rep (repeat)</h2>
    <p>Given a scalar and tensor on top of the stack, this command repeats the tensor a number of times equal to the
      scalar. For example: 
      <pre><code>[0 1 2];3;rep;print;quit;</code></pre>
      This prints 
      <pre><code>Tensor 0
Shape: 3 3
Strides: 3 1
+--------------------+
| +----------------+ |
| | 0.00 1.00 2.00 | |
| +----------------+ |
| +----------------+ |
| | 0.00 1.00 2.00 | |
| +----------------+ |
| +----------------+ |
| | 0.00 1.00 2.00 | |
| +----------------+ |
+--------------------+</code></pre></p>
  </section>

  <section id="cmd-return">
    <h2>return</h2>
    <p>Returns from a function to the place that called that label:
      <pre><code>1;if'past';
l'square'; // Square a scalar on the top of the stack
0;dup;*;
return;

l'past';2;square;square;print;quit;
</code></pre>
      This prints 
      <pre><code>Tensor 0
Shape:
Strides:
16.00</code></pre></p>
  </section>

    <section id="cmd-rotate">
    <h2>rot (rotate)</h2>
    <p>This function returns a 4x4 rotation matrix. The rotation is performed around a 3D vector (taken from the top of the stack) by an angle (stored as the scalar immediately below the vector on the stack). For example: <code>3.141592653589793;6.0;/;[1 1 0];rot;print;quit;</code> will print <pre><code>Tensor 0
Shape: 4 4
Strides: 4 1
+-----------------------------+
| +-------------------------+ |
| | 0.93  0.07  0.35  0.00  | |
| +-------------------------+ |
| +-------------------------+ |
| | 0.07  0.93  -0.35 0.00  | |
| +-------------------------+ |
| +-------------------------+ |
| | -0.35 0.35  0.87  0.00  | |
| +-------------------------+ |
| +-------------------------+ |
| | 0.00  0.00  0.00  1.00  | |
| +-------------------------+ |
+-----------------------------+</code></pre></p>
  </section>

  <section id="cmd-rtd">
    <h2>rtd (render to desktop)</h2>
    <p>This command toggles render to desktop mode. Enabling this mode places the display behind the desktop icons on windows.</p>
  </section>

  <section id="cmd-s">
    <h2>s (slice)</h2>
    <p>Extracts a slice from a tensor along a given axis. The arguments are given as a rank 1 tensor (array) 
      in the form <code>[start end axis]</code>, and will slice the tensor below it from <code>start</code> (inclusive) 
      to <code>end</code> (exclusive) along dimension <code>axis</code>. For example:
      <code>[[0 1][2 3][4 5]];[1 2 1];s;print;quit;</code>
      prints 
      <pre><code>Tensor 0
Shape: 3 1
Strides: 2 1
+----------+
| +------+ |
| | 1.00 | |
| +------+ |
| +------+ |
| | 3.00 | |
| +------+ |
| +------+ |
| | 5.00 | |
| +------+ |
+----------+
</code></pre>
      and
      <pre><code>[[0 1][2 3][4 5]];[1 2 0];s;print;quit;</code></pre>
      prints 
      <pre><code>Tensor 0
2Shape: 1 2
Strides: 2 1
+---------------+
| +-----------+ |
| | 2.00 3.00 | |
| +-----------+ |
+---------------+
</code></pre></p>
  </section>

  <section id="cmd-set">
    <h2>set</h2>
    <p>Sets a named variable to a certain value. The size may be explicitly set, as the variables 
      can be used as uniforms for the shaders. For example 
      <pre><code>[1 2 3];set'vec' 3;</code></pre> 
      would set a variable named <code>vec</code> with the value <code>[1 2 3]</code>, and 
      make it available as a <code>vec3</code> in compute shaders. The valid sizes are 1,2,3,4 for vectors, and 16 
      for a 4x4 matrix. If set is called without a size, the named variable will not be set as a uniform.</p>
  </section>

  <section id="cmd-shape">
    <h2>shape</h2>
    <p>This returns a vector containg the shape of a tensor, if called twice it will return the rank of a tensor as a vector. For example:
      <pre><code>[[[1] [2]][[1] [2]][[1] [2]]];print;shape;print;shape;print;quit;</code></pre> 
      will print 
      <pre><code>Tensor 0
Shape: 3 2 1
Strides: 2 1 1
+-----------------------+
| +-------------------+ |
| | +------+ +------+ | |
| | | 1.00 | | 2.00 | | |
| | +------+ +------+ | |
| +-------------------+ |
| +-------------------+ |
| | +------+ +------+ | |
| | | 1.00 | | 2.00 | | |
| | +------+ +------+ | |
| +-------------------+ |
| +-------------------+ |
| | +------+ +------+ | |
| | | 1.00 | | 2.00 | | |
| | +------+ +------+ | |
| +-------------------+ |
+-----------------------+

Tensor 0
Shape: 3
Strides: 1
+----------------+
| 3.00 2.00 1.00 |
+----------------+

Tensor 0
Shape: 1
Strides: 1
+------+
| 3.00 |
+------+</code></pre></p>
  </section>

  <section id="cmd-size">
    <h2>size</h2>
    <p>This pushes the size of the stack onto the top of the stack.</p>
  </section>

  <section id="cmd-t">
    <h2>t (transpose)</h2>
    <p>Transposes two dimensions in a tensor. The argument is a rank 1 tensor (array) in the form 
      <code>[axis1 axis2]</code>. The tensor below that has those axes swapped. This is equivalent to 
      mirroring along a diagonal. For example:
      <pre><code>[[0 1][2 3]];print;[0 1];t;print;quit;</code></pre>
      prints 
      <pre><code>Tensor 0
Shape: 2 2
Strides: 2 1
+---------------+
| +-----------+ |
| | 0.00 1.00 | |
| +-----------+ |
| +-----------+ |
| | 2.00 3.00 | |
| +-----------+ |
+---------------+

Tensor 0
Shape: 2 2
Strides: 1 2
+---------------+
| +-----------+ |
| | 0.00 2.00 | |
| +-----------+ |
| +-----------+ |
| | 1.00 3.00 | |
| +-----------+ |
+---------------+
</code></pre></p>
  </section>

  <section id="cmd-texture">
    <h2>texture</h2>
    <p>This command takes the tensor on top of the stack, which must be rank 3, 4 component like [512 512 4], and makes it suitable for use as a texture. That is, this commmand enables and generates mipmaps and anisotropic filtering.</p>
  </section>

  <section id="cmd-timeDelta">
    <h2>timeDelta</h2>
    <p>This command pushes the frame time, in seconds, onto the stack as a scalar.</p>
  </section>

  <section id="cmd-toString">
    <h2>toString</h2>
    <p>This command takes the top of the stack, which must be a scalar, and returns it as a string for display.</p>
  </section>

  <section id="cmd-translate">
    <h2>translate</h2>
    <p>This command pushes a 4x4 translation matrix onto the stack, corresponding to a translation by the 3-vector argument on the stack.</p>
  </section>

    <section id="cmd-unext">
    <h2>unext (unextrude)</h2>
    <p>This command performs the reverse of extrusion on the tensor on top of the stack. That is, if the last dimension is of length 1, this command reduces the rank by 1.  If the last dimension isn't of length 1, an error is generated.</p>
  </section>

  <section id="cmd-while">
    <h2>while / for</h2>
    <p>To do a while loop until <code>i</code> is 5, for example, you can do the following:</p>
    <pre><code>[0];set'i' 1; // Set i to 0
l'start';   // The start label
get'i';print;[1];+; // Get i onto the stack and increment it
0;dup;set'i' 1;     // Set i to new value, leave i on stack
[6];-;first;if'start'; // Loop if i != 6
quit;
</code></pre>
  </section>

  <section id="cmd-windowSize">
    <h2>windowSize</h2>
    <p>This command pushes a 2-vector on to the stack with the width and height of the display window.</p>
  </section>

</main>
</body>
</html>
