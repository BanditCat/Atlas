keys;set'keys';input;set'input'; // Set input variables

'main.atl';
include'inc\nav.atl';




size;if'started'; // init code goes here
1024;0;dup;set'texsize';8;fractalNoise;
[0.5 -0.5 -1.5];set'origin' 3;
1; // dummy value to pop off in place of display tensor.


l'started'; // init code complete
pop; // Pop the last display tensor off the stack.

get'input';[3 4 0];s;first;ifn'mouse1skip'; // rotate if mouse 1
get'input';[0 2 0];s;get'rot';+;set'rot' 2;
get'rot';last;100;/;[1 0 0];rot; // rot about y
get'rot';first;100;/;[0 1 0];rot;m; // rot about x
set'worldRotation' 16;
l'mouse1skip';

get'input';[4 5 0];s;first;ifn'mouse2skip'; // forward if mouse 2
[0 0 1 1];get'worldRotation';m;first;[0 3 0];s;[1000 1000 1000];/;
get'origin';+;set'origin' 3;
l'mouse2skip';

get'keys'; [26 27 0];s;first;ifn'wkeyskip';
[0 1 0 1];get'worldRotation';m;first;[0 3 0];s;[1000 1000 1000];/;
get'origin';+;set'origin' 3;
l'wkeyskip';
get'keys'; [22 23 0];s;first;ifn'skeyskip';
[0 -1 0 1];get'worldRotation';m;first;[0 3 0];s;[1000 1000 1000];/;
get'origin';+;set'origin' 3;
l'skeyskip';
get'keys'; [4 5 0];s;first;ifn'akeyskip';
[-1 0 0 1];get'worldRotation';m;first;[0 3 0];s;[1000 1000 1000];/;
get'origin';+;set'origin' 3;
l'akeyskip';
get'keys'; [7 8 0];s;first;ifn'dkeyskip';
[1 0 0 1];get'worldRotation';m;first;[0 3 0];s;[1000 1000 1000];/;
get'origin';+;set'origin' 3;
l'dkeyskip';


0;dup;
windowSize;0;dup;set'wdims' 2;
get'wdims';0;dup;first;1;dup;last;/;0.5;^;e;set'aspect' 1;pop;
c'
float sampleHeight( vec2 uv ){
  return a( ivec4( uv * texsize, 0, 0 ) )\
}
'

vec3 nrml = vec3(0.0, 1.0, 0.0)\
vec3 uvec = vec3(1.0, 0.0, 0.0)\
vec3 vvec = vec3(0.0, 0.0, 1.0)\
vec3 pntpln = vec3(0.0, -1.0, 0.0)\
    
vec3 originFromPoint = pntpln - origin\
vec3 ray = normalize(vec3(tf.xy * vec2( aspect, 1.0 / aspect) / wdims * 2.0 - 1.0, 1.0))\
vec4 ray4 = vec4(ray, 1.0)\
ray4 = worldRotation * ray4\
    
float denominator = dot(nrml, ray4.xyz)\
float tp = dot(nrml, (pntpln - origin)) / denominator\
if (tp < 0.0) { // Intersection behind the origin
  ret[0] = 0.0\
  return\
}
    
vec3 intersect = origin + tp * ray4.xyz\
vec2 uvo = vec2(dot(intersect - pntpln, uvec), dot(intersect - pntpln, vvec))\
vec2 uv = uvo\

mat3 tbn = mat3(uvec, vvec, nrml)\
vec3 vdworld = normalize(origin - intersect)\
vec3 viewDir = normalize(tbn * vdworld)\
    
// Parallax mapping parameters
int maxIterations = 10\
float heightScale = 0.5\ // Adjust based on the desired depth effect
float currentHeight\
float previousHeight = 0.0\
float delta = 0.0\
bool converged = false\
for (int i = 0\ i < 32\ ++i){
// Sample the height map at the current UV
   currentHeight = sampleHeight(uv) * heightScale\

   delta = ( currentHeight - viewDir.z * tp ) * 0.25\
        
   if (abs(delta) < 0.01) {
     converged = true\
     break\
   }
   uv += viewDir.xy * delta\
    // Update 'tp' based on the delta
    tp += delta * viewDir.z\
      // Optional: Clamp UV to valid range to avoid sampling outside the texture
        // uv = clamp(uv, 0.0, 1.0)\
}

if (converged) {
  ret[0] = uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0 ? sampleHeight(uv) : 0.0\
} else {
  ret[0] = 0.0\ // Or some default value if convergence failed
}
' 1 1;
windowSize;[3];0;cat;c''ret[0]=a(ivec4(t.xy,0,0))\' 1 1;













1;if'end'; // Function defintions here, we skip them.

l'fractalNoise'; // Takes 2 arguments, initial grid size, and texture size.
set'fngradsize';
set'fntexsize';
[0.5];set'fnamp';
[1];set'fnseed';

get'fngradsize';get'fntexsize';get'fnamp';get'fnseed';perlin;

l'fnloop';
get'fngradsize';2;*;set'fngradsize';
get'fnamp';[0.5];*;set'fnamp';
get'fnseed';[1.2];+;set'fnseed';
get'fngradsize';get'fntexsize';get'fnamp';get'fnseed';perlin;
get'fntexsize';2;rep;c''ret[0]=a(t)+b(t)\' 2 1;
get'fntexsize';get'fngradsize';/;2;-;if'fnloop';
return;




l'perlin';   // Takes 4 arguments, gradient grid size, texture size, amplitude, and random seed.
set'time' 1;
set'amp' 1;
2;rep;set'texsize' 2;

2;rep;0;dup;set'gradsize' 2;[2];0;cat;
c'  // Push the gradients.
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 )\
    return fract( sin( h ) * 43758.5453123 )\
}
'
ret[0]=t.z == 0 ? sin( hash( vec2( t.xy ), time ) * 2.0 * 3.1415928 ) :
                  cos( hash( vec2( t.xy ), time ) * 2.0 * 3.1415928 )\
' 0 1;

get'texsize';
;c'
float fade( float x ){
    return x*x*x*(x*(x*6.0 - 15.0)+10.0)\
}
float lerp( float a, float b, float t ){
    return a + t*(b - a)\
}
'
vec2 c1 = vec2( t.xy ) * gradsize / texsize\
vec2 fract = fract( c1 )\
ivec2 ic1 = ivec2( c1 )\
ivec2 ic2 = ic1 + ivec2( 1, 0 )\
ivec2 ic3 = ic1 + ivec2( 0, 1 )\
ivec2 ic4 = ic1 + ivec2( 1, 1 )\
c1 = vec2( a( ivec4( ic1, 0, 0 ) ), a( ivec4( ic1, 1, 0 ) ) )\
vec2 c2 = vec2( a( ivec4( ic2, 0, 0 ) ), a( ivec4( ic2, 1, 0 ) ) )\
vec2 c3 = vec2( a( ivec4( ic3, 0, 0 ) ), a( ivec4( ic3, 1, 0 ) ) )\
vec2 c4 = vec2( a( ivec4( ic4, 0, 0 ) ), a( ivec4( ic4, 1, 0 ) ) )\
float fc1 = dot( c1, fract - vec2( 0, 0 ) )\
float fc2 = dot( c2, fract - vec2( 1, 0 ) )\
float fc3 = dot( c3, fract - vec2( 0, 1 ) )\
float fc4 = dot( c4, fract - vec2( 1, 1 ) )\
float u  = fade( fract.x )\
float v  = fade( fract.y )\
float v1 = lerp( fc1, fc2, u )\
float v2 = lerp( fc3, fc4, u )\
float v3 = lerp( v1, v2, v )\
ret[0]=amp*(v3 * 0.5 + 0.5)\
' 1 1;
return;

l'end';

