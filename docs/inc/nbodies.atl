keys;set'keys';input;set'input'; // Set input variables

'main.atl';
include'inc\stdlib.atl';
include'inc\nav.atl'; 


// init code
size;if'started';

[[[-0.5 -0.28868 0 1] [-1.7321 -1 0 1]]
 [[ 0   0.57735  0 1] [0 2 0 1]] 
 [[ 0.5 -0.28868 0 1] [1.7321 -1 0 1]]];
6;[3 2 4];c''''
vec4 r = vec4( a( ivec4( tf, 0, 0 ) ),
               a( ivec4( tf, 1, 0 ) ),
               a( ivec4( tf, 2, 0 ) ),
               a( ivec4( tf, 3, 0 ) ) )\
ret[0] = r\' 1 1 4;   // take our vertices and colors and put them in a texture.


[200];set'sqrtParticles' 1;
get'sqrtParticles';[2];^;[3];*;first;set'vertexCount';

nav3d;[0 0 1.8];set'origin' 3; // set origin
0;set'time';

6;get'sqrtParticles';0;dup;0;cat;[4];0;cat;
c'''
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 )\
    return fract( sin( h ) * 43758.5453123 )\
}
'
ret[0] = vec4( hash( tf, 0.0 ) * 2.0 - 1.0, hash( tf, 1.0 ) * 2.0 - 1.0, hash( tf, 2.0 ) * 2.0 - 1.0,
               pow( ( hash( tf, 3.0 ) * 100.0 + 1.0 ) * 0.000001, 1.0 / 3.0 ) )\
' 0 1 4; // Randomly place particles and set mass


6;get'sqrtParticles';0;dup;0;cat;[4];0;cat;
c'''
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 )\
    return fract( sin( h ) * 43758.5453123 )\
}
'
ret[0] = vec4( hash( tf, 4.0 ) * 2.0 - 1.0, hash( tf, 5.0 ) * 2.0 - 1.0, hash( tf, 6.0 ) * 2.0 - 1.0,
               hash( tf, 7.0 ) )\
' 0 1 4; // Randomly set velocity and colors









1;
l'started';
timeDelta;e;set'td' 1;
// stack: last frame, velocity, position, verts
get'time';timeDelta;+;set'time';
[90];windowSize;0;cat;[0.1 10];0;cat;proj;set'proj' 16;

pop;

nav3d;

// stack: velocity, position, verts
6;1;dup;shape;
c'''
const float timescale = 0.01\
'
vec4 position = bf( tf )\
vec3 pos = position.xyz\
float radius = position.w\
float mass = radius * radius * radius\
vec4 velocity = af( tf )\
vec3 vel = velocity.xyz\
float color = velocity.w\
float delta = timescale * td\
int iter = int( sqrtParticles )\

vec3 grav = vec3( 0.0 )\
for( int x1 = 0\ x1 < iter\ ++x1 )
  for( int y1 = 0\ y1 < iter\ ++y1 ){
    vec2 i1 = vec2( x1, y1 ) + vec2( 0.5 )\
    vec4 iposition = bf( i1 )\
    vec3 ipos = iposition.xyz\
    float imass = iposition.w * iposition.w * iposition.w\
    float distance = length( ipos - pos )\
    if( distance > 0.0 ){
      float force = imass * mass / ( distance * distance )\
      vec3 forcevec = normalize( ipos - pos ) * force\
      grav += forcevec\
    }
  }
   


grav *= 1000000.0\
ret[ 0 ] = vec4( vel + grav * delta, color )\
ret[ 1 ] = vec4( pos + vel * delta + 0.5 * grav * delta * delta, radius )\
' 2 2 4;

2;dup;2;dup;2;dup;
// stack: velocity, position, verts, velocity, position, verts 

get'vertexCount';windowSize;[4];0;cat;
additive;
c'
vec3 hsvToRgb(float H, float S, float V) {
    float C = V * S\ // Chroma
    float H_prime = H / 60.0\
    float X = C * (1.0 - abs(mod(H_prime, 2.0) - 1.0))\

    vec3 rgb\

    if (0.0 <= H_prime && H_prime < 1.0) {
        rgb = vec3(C, X, 0.0)\
    }
    else if (1.0 <= H_prime && H_prime < 2.0) {
        rgb = vec3(X, C, 0.0)\
    }
    else if (2.0 <= H_prime && H_prime < 3.0) {
        rgb = vec3(0.0, C, X)\
    }
    else if (3.0 <= H_prime && H_prime < 4.0) {
        rgb = vec3(0.0, X, C)\
    }
    else if (4.0 <= H_prime && H_prime < 5.0) {
        rgb = vec3(X, 0.0, C)\
    }
    else if (5.0 <= H_prime && H_prime < 6.0) {
        rgb = vec3(C, 0.0, X)\
    }
    else {
        rgb = vec3(0.0, 0.0, 0.0)\
    }

    float m = V - C\
    rgb += vec3(m, m, m)\

    // Clamp the result to [0,1]
    rgb = clamp(rgb, 0.0, 1.0)\

    return rgb\
}
out vec4 unitvec\
out vec3 color\
'
vec4 vert = cf( vec2( float(i%3) + 0.5, 0 ) )\
vec4 particle = bf( vec2( ivec2( (i/3) % int( sqrtParticles ), (i/3) / int( sqrtParticles ) ) ) )\
vec4 velocity = af( vec2( ivec2( (i/3) % int( sqrtParticles ), (i/3) / int( sqrtParticles ) ) ) )\
vec4 hpart = vec4( particle.xyz, 0.0 )\

vec3 right = vec3( worldUnrotation[ 0 ][ 0 ], worldUnrotation[ 1 ][ 0 ], worldUnrotation[ 2 ][ 0 ])\
vec3 up    = vec3( worldUnrotation[ 0 ][ 1 ], worldUnrotation[ 1 ][ 1 ], worldUnrotation[ 2 ][ 1 ])\
vec3 wp = particle.xyz + ( right * vert.x + up * vert.y ) * particle.w\

ret = proj*worldUnrotation*( hpart +
                             -vec4( origin, 0.0 ) + //rot *
                             vec4(wp, 1.0 ) )\
	   
unitvec = vec4( cf( vec2( float(i%3) + 0.5, 1 ) ).xyz, 1.0 )\ //ret.z / ret.w )\
color = hsvToRgb( velocity.w * 360.0, 0.7, 1.0 )\
'
in vec4 unitvec\
in vec3 color\
'
float ul = length( unitvec.xy )\
float alpha = 1.0 - ul\
alpha = exp( -ul*ul*4.0 )\ 
float weight = ul < 1.0 ? alpha : 0.0\//exp( -10.0 * unitvec.w )\
vec3 wcolor = weight * color * alpha\
ret[0] = vec4( wcolor, weight )\

' 3 1 4;
additive;
// stack: frame*, velocity, position, verts

6;1;dup;shape;c''''
vec4 wcolor = af( tf )\
ret[0]= wcolor / wcolor.a\
' 1 1 4;
// stack: frame, velocity, position, verts


l'end';


