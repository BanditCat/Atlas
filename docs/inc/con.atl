workspace'con';



inited;if'initEnd';  // Do init
1;inited=;
[0.01];posCutoff=;
'';buffer=;
[0];cursor= 1;
320;commandHistorySize=;
0;commandHistory=;
'';commandHistorySizes=;
[0];histPos=;
[0];scrollUp=;

l'initEnd';



// Toggle console state 
std.keyPresses;[53 54 0];s;first;ifn'noTilde';
textInput;pop;
1;visible;-;visible=;
visible;ifn'noTilde';
[0.1];pos= 1;
l'noTilde';




pos;visible;e;pos;-;[0.08];timeDelta;165;*;e;^;*;+;pos= 1;


pos;posCutoff;-;unext;ifn'end';   // Skip if pos < 0.05;
prevSize;if'skipPrevSizeSetup';
// console init here, its visible and were setting stack size
size;prevSize=;
textInput;pop;
1; // place a dummy because were now drawing;
l'skipPrevSizeSetup';


pop; // pop last display


// Input
textInput;0;dup;shape;unext;tilen=;
tilen;ifn'noInput';
buffer;shape;unext;ifn'skipCat';
// textInput on top of stack
buffer;[0];cursor;[0];0;cat;0;cat;s;1;raise;0;cat;
buffer;cursor;buffer;shape;0;cat;[0];0;cat;s;0;cat;
l'skipCat';
buffer=;'';
l'noInput';
pop;cursor;tilen;e;+;cursor= 1;

// DOING THE THING!!! :D :D :D
std.keyPresses;[40 41 0];s;unext;ifn'skipEval';
buffer;printLine;buffer;eval;
commandHistorySizes;buffer;shape;0;cat;commandHistorySizes=;
buffer;
  0;commandHistorySize;buffer;shape;unext;-;rep;0;cat;e;
  commandHistory;shape;shape;unext;if'haveHistory';
  commandHistory=;
1;if'doneHistory';
  l'haveHistory';
  commandHistory;1;raise;0;cat;commandHistory=;
l'doneHistory';
commandHistorySizes;shape;histPos=;

commandHistory;commandHistorySizes;pop;pop;
'';buffer=;[0];cursor= 1;
l'skipEval';


std.keyPresses;[82 83 0];s;unext;ifn'skipUp';
histPos;unext;ifn'skipUp'; // Stop if already at 0
histPos;[1];-;histPos=; // Decrement index
commandHistorySizes;histPos;histPos;[1];+;0;cat;[0];0;cat;s;len=;
commandHistory;histPos;histPos;[1];+;0;cat;[0];0;cat;s;first;rawRow=;
rawRow;[0];len;0;cat;[0];0;cat;s;buffer=;
buffer;shape;cursor= 1;
l'skipUp';

std.keyPresses;[81 82 0];s;unext;ifn'skipDown';
histPos;[1];+;histPos=;
histPos;commandHistorySizes;shape;-;[1];+;unext;if'clearBuffer';
commandHistorySizes;histPos;histPos;[1];+;0;cat;[0];0;cat;s;len=;
commandHistory;histPos;histPos;[1];+;0;cat;[0];0;cat;s;first;rawRow=;
rawRow;[0];len;0;cat;[0];0;cat;s;buffer=;
buffer;shape;cursor= 1;
1;if'skipDown';
l'clearBuffer';
commandHistorySizes;shape;histPos=;
'';buffer=;
[0];cursor= 1;
l'skipDown';


// cursor
std.keyPresses;[79 80 0];s;unext;ifn'skipRight';
[1];cursor;+;cursor= 1;
buffer;shape;cursor;-;unext;if'skipRight';
buffer;shape;cursor= 1;
l'skipRight';
std.keyPresses;[80 81 0];s;unext;ifn'skipLeft';
cursor;[1];-;cursor= 1;
cursor;unext;if'skipLeft';
[0];cursor= 1;
l'skipLeft';
std.keyPresses;[74 75 0];s;unext;ifn'skipHome';
[0];cursor= 1;
l'skipHome';
std.keyPresses;[77 78 0];s;unext;ifn'skipEnd';
buffer;shape;cursor= 1;
l'skipEnd';

// del
std.keyPresses;[42 43 0];s;unext;ifn'skipBksp';
cursor;unext;ifn'skipBksp';
buffer;[0];cursor;[1];-;0;cat;[0];0;cat;s;
buffer;cursor;buffer;shape;0;cat;[0];0;cat;s;
0;cat;buffer=;
cursor;[1];-;cursor= 1;
l'skipBksp';
std.keyPresses;[76 77 0];s;unext;ifn'skipDel';
buffer;shape;cursor;-;unext;ifn'skipDel';
buffer;[0];cursor;0;cat;[0];0;cat;s;
buffer;cursor;[1];+;buffer;shape;0;cat;[0];0;cat;s;
0;cat;buffer=;
l'skipDel';




// set scroll for long lines
windowSize;[12 16];/;floor;[1 1];-;charswid=;
buffer;shape;charswid;[0 1 0];s;-;0;dup;unext;ifn'shortLine';
[12];*;scroll= 1;
1;if'doneScroll';
l'shortLine';pop;[0];scroll= 1;
l'doneScroll';



//Add a blank tex or the buffer.
input;[0 2 0];s;mouse;+;mouse= 2;
buffer;shape;unext;ifn'skipTex';
buffer;e;scroll;[2];/;[0];0;cat;charswid;[0 1 0];s;[6];*;0;cat;[8];0;cat;[0 0 1 1];+;std.textAreaToFlatTexture;
1;if'skipConst';
l'skipTex';
' ';e;[0 0 7 9];std.textAreaToFlatTexture;
l'skipConst';
0;dup;shape;[0 2 0];s;tdims= 2;
tdims;[0 1 0];s;[6];buffer;shape;*;[1];+;-;unext;ifn'noRedim';
[6];buffer;shape;*;tdims;[1 2 0];s;0;cat;tdims= 2;
l'noRedim';


// Create output view.
input;[2 3 0];s;[4];*;scrollUp;+;scrollUp=;
std.keyPresses;[75 76 0];s;unext;ifn'nopgUp';scrollUp;[4];+;scrollUp=;l'nopgUp';
std.keyPresses;[78 79 0];s;unext;ifn'nopgDown';scrollUp;[4];-;scrollUp=;l'nopgDown';
scrollUp;unext;if'nonneg';[0];scrollUp=;l'nonneg';

charswid;scrollUp;0;cat;textBufferView;
[0 0];charswid;0;cat;[1 1 6 8];*;[0 0 1 1];+;std.textAreaToFlatTexture;
0;dup;shape;[0 2 0];s;otdims= 2;

2;dup;texture; // texture the display tensor so we can blur it.
0;dup;shape;[0 2 0];s;windowSize;0;dup;wdims= 2;/;0;dup;wmult= 2;log;wadd= 2;
6;windowSize;[4];0;cat;
c'
vec4 verts[] = vec4[](
vec4( -1.0, -1.0,0.0,1.0 ),
vec4(  1.0, -1.0,0.0,1.0 ), 
vec4( -1.0,  1.0,0.0,1.0 ), 
vec4(  1.0,  1.0,0.0,1.0 ),
vec4( -1.0,  1.0,0.0,1.0 ),
vec4(  1.0, -1.0,0.0,1.0 ) 
);
'
ret = verts[ i ];
''
float blur = con_pos * 5.0 - 2.5;
if( (1.0 - tf.y / con_wdims.y) < ( con_pos * 0.8 ) ){
  float aboveLine = ( con_pos * 0.8 * con_wdims.y ) - ( con_wdims.y - tf.y );
  vec4 text = vec4( 0.0 );
  if( aboveLine > con_tdims.y * 2.0 && tf.x < con_otdims.x * 2.0 )
     text = vec4( 1.0 - bf( vec2( tf.x / 2.0, ( aboveLine - ( con_tdims.y * 2.0 + 1.0 ) ) / 2.0 ) ).x ) * 0.7;
  if( aboveLine < 1.0 || ( aboveLine > con_tdims.y * 2.0 - 1.0 && aboveLine < con_tdims.y * 2.0 ) )
    text = vec4( 0.0, 1.0, 0.0, 0.0 );
  if( aboveLine > 1.0 && aboveLine < con_tdims.y * 2.0 - 1.0 && ( tf.x ) > 1.0 && ( tf.x ) < con_tdims.x * 2.0 + 2.0 )
    text = vec4( 1.0 - cf( vec2( tf.x / 2.0, aboveLine / 2.0 ) ).x );
  if( aboveLine > 1.0 && aboveLine < 3.0 && ( tf.x + con_scroll ) >= con_cursor * 12.0 && ( tf.x + con_scroll ) < ( con_cursor + 1.0 ) * 12.0 )
    text.r = 1.0;



  float l = blur + con_wadd.x;
  vec2 uv = tf * con_wmult;

  vec2 d = con_wmult * exp2(blur) * 0.4; 

  vec4 acc = af(vec4(uv, 0.0, l)) * 0.38;

  acc += af(vec4(uv + d, 0.0, l)) * 0.155;
  acc += af(vec4(uv - d, 0.0, l)) * 0.155;
  acc += af(vec4(uv + vec2(d.x, -d.y), 0.0, l)) * 0.155;
  acc += af(vec4(uv + vec2(-d.x, d.y), 0.0, l)) * 0.155;

  ret[ 0 ] = acc * 0.5 + text;
} else
  ret[ 0 ] = af( vec4( tf * con_wmult, 0.0, 0.0 ) );

' 3 1 40 0;




// quit maybe
std.keyState;[41 42 0];s;first;
std.gamepadState;[19 20 0];s;first;+;
std.gamepadState;[20 21 0];s;first;+;
ifn'go';
quit;  // Quit if escape pressed.
l'go';

continue;


l'end';


//cleanup
prevSize;ifn'cleanSkip';pos;posCutoff;-;unext;if'cleanSkip';
l'loopPop';
size;prevSize;-;ifn'setPrevSize';
pop;1;if'loopPop';
l'setPrevSize';
0;prevSize=;
l'cleanSkip';