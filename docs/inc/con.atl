workspace'con';



inited;if'initEnd';  // Do init
1;inited=;
[0.01];posCutoff=;
'';buffer=;
[0];cursor= 1;
320;commandHistorySize=;
0;commandHistory=;
'';commandHistorySizes=;
[0];histPos=;

l'initEnd';



// Toggle console state 
std.keyPresses;[53 54 0];s;first;ifn'noTilde';
textInput;pop;
1;visible;-;visible=;
visible;ifn'noTilde';
[0.1];pos= 1;
l'noTilde';


pos;visible;e;pos;-;[0.08];timeDelta;165;*;e;^;*;+;pos= 1;


pos;posCutoff;-;unext;ifn'end';   // Skip if pos < 0.05;
prevSize;if'skipPrevSizeSetup';
// console init here, its visible and were setting stack size
size;prevSize=;
1; // place a dummy because were now drawing;
l'skipPrevSizeSetup';


pop; // pop last display


// Input
textInput;0;dup;shape;unext;tilen=;
tilen;ifn'noInput';
buffer;shape;unext;ifn'skipCat';
// textInput on top of stack
buffer;[0];cursor;[0];0;cat;0;cat;s;1;raise;0;cat;
buffer;cursor;buffer;shape;0;cat;[0];0;cat;s;0;cat;
l'skipCat';
buffer=;'';
l'noInput';
pop;cursor;tilen;e;+;cursor= 1;

// DOING THE THING!!! :D :D :D
std.keyPresses;[40 41 0];s;unext;ifn'skipEval';
buffer;eval;
commandHistorySizes;buffer;shape;0;cat;commandHistorySizes=;
buffer;
  0;commandHistorySize;buffer;shape;unext;-;rep;0;cat;e;
  commandHistory;shape;shape;unext;if'haveHistory';
  commandHistory=;
1;if'doneHistory';
  l'haveHistory';
  commandHistory;1;raise;0;cat;commandHistory=;
l'doneHistory';
commandHistorySizes;shape;histPos=;

commandHistory;commandHistorySizes;pop;pop;
'';buffer=;[0];cursor= 1;
l'skipEval';


std.keyPresses;[82 83 0];s;unext;ifn'skipUp';
histPos;unext;ifn'skipUp'; // Stop if already at 0
histPos;[1];-;histPos=; // Decrement index
commandHistorySizes;histPos;histPos;[1];+;0;cat;[0];0;cat;s;len=;
commandHistory;histPos;histPos;[1];+;0;cat;[0];0;cat;s;first;rawRow=;
rawRow;[0];len;0;cat;[0];0;cat;s;buffer=;
buffer;shape;cursor= 1;
l'skipUp';

std.keyPresses;[81 82 0];s;unext;ifn'skipDown';
histPos;[1];+;histPos=;
histPos;commandHistorySizes;shape;-;[1];+;unext;if'clearBuffer';
commandHistorySizes;histPos;histPos;[1];+;0;cat;[0];0;cat;s;len=;
commandHistory;histPos;histPos;[1];+;0;cat;[0];0;cat;s;first;rawRow=;
rawRow;[0];len;0;cat;[0];0;cat;s;buffer=;
buffer;shape;cursor= 1;
1;if'skipDown';
l'clearBuffer';
commandHistorySizes;shape;histPos=;
'';buffer=;
[0];cursor= 1;
l'skipDown';


// cursor
std.keyPresses;[79 80 0];s;unext;ifn'skipRight';
[1];cursor;+;cursor= 1;
buffer;shape;cursor;-;unext;if'skipRight';
buffer;shape;cursor= 1;
l'skipRight';
std.keyPresses;[80 81 0];s;unext;ifn'skipLeft';
cursor;[1];-;cursor= 1;
cursor;unext;if'skipLeft';
[0];cursor= 1;
l'skipLeft';
std.keyPresses;[74 75 0];s;unext;ifn'skipHome';
[0];cursor= 1;
l'skipHome';
std.keyPresses;[77 78 0];s;unext;ifn'skipEnd';
buffer;shape;cursor= 1;
l'skipEnd';

// del
std.keyPresses;[42 43 0];s;unext;ifn'skipBksp';
cursor;unext;ifn'skipBksp';
buffer;[0];cursor;[1];-;0;cat;[0];0;cat;s;
buffer;cursor;buffer;shape;0;cat;[0];0;cat;s;
0;cat;buffer=;
cursor;[1];-;cursor= 1;
l'skipBksp';
std.keyPresses;[76 77 0];s;unext;ifn'skipDel';
buffer;shape;cursor;-;unext;ifn'skipDel';
buffer;[0];cursor;0;cat;[0];0;cat;s;
buffer;cursor;[1];+;buffer;shape;0;cat;[0];0;cat;s;
0;cat;buffer=;
l'skipDel';



//Add a blank tex or the buffer.
buffer;shape;unext;ifn'skipTex';
buffer;e;std.textToTexture;
1;if'skipConst';
l'skipTex';
' ';e;std.textToTexture;
l'skipConst';
0;dup;shape;[0 2 0];s;[2 2];/;tdims= 2;

// set scroll for long lines
windowSize;[0 1 0];s;[12];/;floor;[1];-;charswid=;
buffer;shape;charswid;-;0;dup;unext;ifn'shortLine';
[12];*;scroll= 1;
1;if'doneScroll';
l'shortLine';pop;[0];scroll= 1;
l'doneScroll';



1;dup;texture; // texture the display tensor so we can blur it.
0;dup;shape;[0 2 0];s;windowSize;0;dup;wdims= 2;/;0;dup;wmult= 2;log;wadd= 2;
[[-1 -1][-1 1][1 1][1 1][1 -1][-1 -1]];6;windowSize;[4];0;cat;
c''
ret = vec4( a( ivec4( i, 0, 0, 0 ) ), a( ivec4( i, 1, 0, 0 ) ), 0.0, 1.0 );
''
float blur = con_pos * 5.0 - 2.5;
if( (1.0 - tf.y / con_wdims.y) < ( con_pos * 0.8 ) ){
  float aboveLine = ( con_pos * 0.8 * con_wdims.y ) - ( con_wdims.y - tf.y );
  vec4 text = vec4( 0.0 );
  if( aboveLine < 1.0 || ( aboveLine > con_tdims.y && aboveLine < con_tdims.y + 1.0 ) )
    text = vec4( 0.0, 1.0, 0.0, 0.0 );
  if( aboveLine > 1.0 && aboveLine < con_tdims.y && ( tf.x + con_scroll ) > 1.0 && ( tf.x + con_scroll ) < con_tdims.x + 2.0 )
    text = vec4( 1.0 - cf( vec2( ( tf.x + con_scroll ), aboveLine ) * 2.0 ).x );
  if( aboveLine > 1.0 && aboveLine < 3.0 && ( tf.x + con_scroll ) >= con_cursor * 12.0 && ( tf.x + con_scroll ) < ( con_cursor + 1.0 ) * 12.0 )
    text.r = 1.0;



  float l = blur + con_wadd.x;
  vec2 uv = tf * con_wmult;

  vec2 d = con_wmult * exp2(blur) * 0.4; 

  vec4 acc = bf(vec4(uv, 0.0, l)) * 0.38;

  acc += bf(vec4(uv + d, 0.0, l)) * 0.155;
  acc += bf(vec4(uv - d, 0.0, l)) * 0.155;
  acc += bf(vec4(uv + vec2(d.x, -d.y), 0.0, l)) * 0.155;
  acc += bf(vec4(uv + vec2(-d.x, d.y), 0.0, l)) * 0.155;

  ret[ 0 ] = acc * 0.5 + text;
} else
  ret[ 0 ] = bf( vec4( tf * con_wmult, 0.0, 0.0 ) );

' 3 1 40 0;




// quit maybe
std.keyState;[41 42 0];s;first;
std.gamepadState;[19 20 0];s;first;+;
std.gamepadState;[20 21 0];s;first;+;
ifn'go';
quit;  // Quit if escape pressed.
l'go';

continue;


l'end';


//cleanup
prevSize;ifn'cleanSkip';pos;posCutoff;-;unext;if'cleanSkip';
l'loopPop';
size;prevSize;-;ifn'setPrevSize';
pop;1;if'loopPop';
l'setPrevSize';
0;prevSize=;
l'cleanSkip';