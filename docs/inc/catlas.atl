include'inc\catlib.atl';

// Exit
cat.keyState;[41 42 0];s;first;
cat.gamepadState;[19 20 0];s;first;+;
cat.gamepadState;[20 21 0];s;first;+;
ifn'go';
quit;  // Quit if escape pressed.
l'go';


size;if'started'; // init code goes here
fullscreen;
'inc\\catlas.ktl';unkettle;pop;
[2.0];progress= 1;

1;if'skipreset';
l'reset';
[1024];dim= 1; // constants
[0.2];hscale= 1;
[0.5];hscale;[2];/;0;cat;[0.5];0;cat;hmapCenter= 3;
[0.05];waterLevel= 1;
[30.0];waterFogScale= 1;
[0.0 0.15 0.25];waterColor= 3;
[4096 4096 1];shadowSize= 3;
[0.001];shadowBias= 1;
[50];softShadows= 1;
[0.008];sableScale= 1;
[0];timer= 1;
[949];lowInstanceCount= 1;
[50];highInstanceCount= 1;
lowInstanceCount;highInstanceCount;+;totalInstances=;
[7];instanceVars= 1;
[1.5 1.5];ssaa=;
totalInstances;[500];0;cat;fireworksDims= 2;
windowSize;ssaa;*;wdims= 2;
[0.001];fireworkSize= 1;
[0.0003];fireworksSpeed= 1;
[-0.000004];gravity= 1;
[20];reticleSnappiness= 1;
[0 0 0];selectedReticle=;
[5];numJobs= 1;
[99];numJobs;first;rep;uiNums=;
[0.2];uiSize= 1;
[0];activeJob= 1;
[0.99];gameover= 1;
[3];gameoverTime= 1;
[360];[3.1415926535897932384626433832795];*;jobFacing= 1;
[0];nukeBar= 1;
return;
l'skipreset';
reset;

dim;first;2;rep;set'texsize' 2;
img'inc\terrain.bmp';0;dup;shape;[1 2 0];s;ttexsize= 1;
6;[1];ttexsize;0;cat;[4];0;cat;
c''''ret[0] = vec4( a( ivec4( 0, tf.y, 0, 0 ) ),
                    a( ivec4( 0, tf.y, 1, 0 ) ),  
                    a( ivec4( 0, tf.y, 2, 0 ) ), 1.0 );' 1 1 40 0;texture;
dim;first;4;cat.fractalNoise;
// get minmax
0;dup;transferStart;transferEnd;minmax;0;dup;last;1;dup;first;-;e;hspan= 1;first;-1;*;e;hbias= 1;


6;texsize;[1];0;cat;c''''ret[0]=( a( ivec4( tf, 0, 0 ) ) + hbias) / hspan;' 1 1 100 0;texture;
[150 400];set'lrot' 2;
lrot;first;-300;/;[0 1 0];rot; // rot about y
lrot;last;-300;/;[1 0 0];rot;m; // rot about x
set'lightRotation' 16;

cat.nav3d;
[0.5 0.5 1.0];cat.origin= 3;
[171 134];cat.3dnavParam=;

6;wdims;[4];0;cat;
c''''ret[ 0 ]=vec4( 0 );' 0 1 400 0; // dummy value to pop off in place of display tensor.

1;
l'started'; // init code complete
loadedKettle;if'kettled';
pop;
progress;unext;ifn'loop4';
unkettle;e;progress= 1;
// load bar
windowSize;wwdims= 2;6;wwdims;[4];0;cat;c''''ret[ 0 ] = tf.x / wwdims.x > 2.0 - progress ? vec4( 0.0 ) : vec4( 1.0 - abs( tf.y - wwdims.y / 2.0 ) / 30.0 );' 0 1 400 0;
continue;
l'loop4';
1;loadedKettle=;
/////////////////////////////////////////////////
// instance/unkettle init
//print;quit; // stack:  lowverts lowindices mat highverts highindices bones animcount prevframe hmap gradient
2;raise;0;dup;shape;[0 2 0];s;matDim= 2;2;bury;
6;raise;e;animCount= 1; // stack:  lowverts lowindices mat highverts highindices bones prevframe hmap gradient
0;dup;shape;[0 1 0];s;lowVertexCount= 1;
3;dup;shape;[0 1 0];s;highVertexCount= 1;
5;dup;shape;0;dup;[0 1 0];s;frameCount= 1;[1 2 0];s;animCount;/;boneCount= 1;
2;dup;shape;[0 2 0];s;atlasSize= 2;

1;raise; // get indices
0;dup;shape;lowIndexCount= 1;
1;bury;  // put indices back
4;raise; // get indices
0;dup;shape;highIndexCount= 1;
4;bury;  // put indices back
//print;quit; // stack:  lowverts lowindices mat highverts highindices bones prevframe hmap gradient

0;dup;6;dup;bakeVat; // stack:  lowVAT lowverts lowindices mat highverts highindices bones prevframe hmap gradient
4;dup;7;dup;bakeVat;
2;raise;pop;4;raise;pop;5;raise;pop; // stack:  highVAT lowVAT lowindices mat highindices prevframe hmap gradient
2;dup;lowindscpu=;4;dup;highindscpu=;
7;raise;7;raise;7;raise;
resetInstances;
8;bury;

//print;quit; frame hmap grad highvat lowvat lowinds mat highinds instances
/////////////////////////////////////////////////
//  init fireworks
6;fireworksDims;[4];0;cat;c''''
ret[ 0 ] = vec4( 0.0 );
' 0 1 4 0;
9;bury;
6;fireworksDims;[4];0;cat;c''''
ret[ 0 ] = vec4( 0.0 );
' 0 1 4 0;
9;bury;
[0 0 0];11;bury; //frame hmap grad highvat lowvat lowinds mat highinds instances fireworksPos fireworksVel

0;totalInstances;first;rep;6;totalInstances;c''''ret[ 0 ] = a( t );' 1 1 0 0;transferStart;12;bury; // fake instance sort
[0];6;[1];c''''ret[ 0 ] = a( t );' 1 1 0 0;transferStart;13;bury; // fake height

// set up images
img'inc\ui.png';6;[1152 1024 4];c''''ret[ 0 ] = vec4( a( ivec4( ivec2( tf.xy ), 0, 0 ) ),
                                        a( ivec4( ivec2( tf.xy ), 1, 0 ) ),
                                        a( ivec4( ivec2( tf.xy ), 2, 0 ) ),
                                        a( ivec4( ivec2( tf.xy ), 3, 0 ) ) );' 1 1 40 0;
texture;14;bury;

// fake instances;
6;totalInstances;instanceVars;0;cat;c''''ret[ 0 ] = 0.0;' 0 1 0 0;transferStart;15;bury;







//////////////////////////////////////////////////////////////
// actual start post init, do controls here
l'kettled';


activeJob;cat.inputState;[2 3 0];s;+;numJobs;+;numJobs;%;activeJob= 1;
cat.keyPresses;[8 9 0];s;first;cat.gamepadPresses;[7 8 0];s;first;+;ifn'actionplus';
activeJob;[1];+;numJobs;%;activeJob= 1;
l'actionplus';
cat.keyPresses;[20 21 0];s;first;cat.gamepadPresses;[6 7 0];s;first;+;ifn'actionminus';
activeJob;numJobs;[1];-;+;numJobs;%;activeJob= 1;
l'actionminus';
cat.inputState;[4 5 0];s;first;ifn'norotateFacing';
jobFacing;cat.inputState;[0 1 0];s;-;[360.0];[3.1415926535897932384626433832795];[2];*;*;%;jobFacing= 1;
l'norotateFacing';
cat.gamepadState;[16 17 0];s;first;ifn'nogpsetfacing';
cat.gamepadState;[2 4 0];s;l;0.8;-;ifn'nogpsetfacing';
cat.gamepadState;[2 4 0];s;atan;-360;*;e;
cat.forward;[0 1 0];s;cat.forward;[2 3 0];s;0;cat;atan;360;*;e;[360];[3.1415926535897932384626433832795];*;+;-;
[360];[3.1415926535897932384626433832795];[2];*;*;+;[360];[3.1415926535897932384626433832795];[2];*;*;%;
jobFacing= 1;
l'nogpsetfacing';
cat.inputPresses;[3 4 0];s;cat.gamepadPresses;[15 16 0];s;+;first;ifn'nomouseclick';
numJobs;[1];-;activeJob;==;first;ifn'nomouseclick';
nukeBar;[0.75];+;nukeBar= 1;
l'nomouseclick';
nukeBar;[2];-;first;if'skipnukedec';
nukeBar;first;ifn'skipnukedec';
nukeBar;dt;-;nukeBar= 1;
l'skipnukedec';


windowSize;ssaa;*;wdims= 2;
wdims;[1 2 0];s;uiSize;*;0;dup;[2];/;numJobs;*;1;bury;0;cat;uiDims= 2;
timer;timeDelta;e;+;[3333.33333333];%;timer= 1;
timeDelta;e;dt= 1;
cat.nav3d;

/////////////////////////////////////////////
// reset sables maybe
8;raise;
cat.gamepadPresses;[17 18 0];s;cat.keyPresses;[21 22 0];s;+;unext;ifn'noreset';
pop;resetInstances;
l'noreset';
nukeBar;[1];-;first;ifn'noexplodify';
nukeBar;[2];-;first;if'noexplodify';
[2.1];nukeBar= 1;
explodify;
l'noexplodify';
8;bury;

////////////////////////////////////////////////////////////////////
//  Check for exploding sables.
8;raise; // instances
totalInstances;instanceVars;0;cat;reshape;
0;dup;6;totalInstances;c''''
float animIdx = a(ivec4( t.x, 4, 0, 0));
float animStart = a(ivec4( t.x, 5, 0, 0));
int anim = int( animIdx ); 
float pframe = clamp( timer - animStart, 0.0, 10000000000000000.0 );
float frame = pframe * 24.0;
ret[ 0 ] = ( anim == 2 && frame > 80.0 ) ? 0.0 : 1.0;
' 1 1 0 0;
3;raise;1;dup;3;dup;
totalInstances;unext;3;*;dim;dim;0;cat;[1];0;cat;additive;c'
const vec4 verts[3] = vec4[](
    vec4( 0.0,        2.0, 0.0, 1.0),   // top
    vec4(-1.732051, -1.0, 0.0, 1.0),   // bottom left  (-v3)
    vec4( 1.732051, -1.0, 0.0, 1.0)    // bottom right (v3)
);
out vec2 tripos;
'
int vert = gl_VertexID % 3;
int idx = gl_VertexID / 3;
vec4 pos = vec4( a( ivec4( idx, 2, 0, 0 ) ), a( ivec4( idx, 0, 0, 0 ) ), 0.0, 0.0 );
pos.xy = pos.xy * 2.0 - 1.0;
tripos = verts[ vert ].xy;
ret = b( ivec4( idx, 0, 0, 0 ) ) == 0.0 ? ( ( verts[ vert ] * vec4( 0.04, 0.04, 1.0, 1.0 ) + pos ) ) : vec4( -1.0 );
'
in vec2 tripos;
'
ret[ 0 ] = clamp( 1.0 - length( tripos ), 0.0, 1.0 ) * -0.1;
' 2 1 100 1;additive;
3;bury;

//////////////////////////////////////////////////////////////////
// fireworks
// 0           1         2     3    4    5       6      7       8   9        10    11     
// explodemask instances frame hmap grad highvat lowvat lowinds mat highinds fwpos fwvel
//0;dup;12;bury;
11;bury;11;dup;
11;raise;11;raise;3;dup;3;bury; // fwpos fwvel explodemask instancescopy ...
6;fireworksDims;[4];0;cat;
c'''
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
float frameTime = dt * 165.0;
vec4 posSamp = af( vec4( tf, 0.0, 0.0 ) );
vec3 pos = posSamp.xyz;
float tint = posSamp.w;
vec4 velSamp = bf( vec4( tf, 0.0, 0.0 ) );
vec3 vel = velSamp.xyz;
float fade = velSamp.w;
vec3 ipos = vec3( d( ivec4( tf.x + 0.5, 0, 0, 0 ) ), d( ivec4( tf.x + 0.5, 1, 0, 0 ) ), d( ivec4( tf.x + 0.5, 2, 0, 0 ) ) );
float ctint = d( ivec4( tf.x + 0.5, 6, 0, 0 ) );
bool explode = c( ivec4( tf.x + 0.5, 0, 0, 0 ) ) == 0.0;
pos += vel * frameTime;
vel += vec3( 0.0, gravity * frameTime, 0.0 );
fade -= 0.0001 * frameTime;
vec3 randomVel = vec3( hash( vec2( tf * 5.0 ), timer ), hash( vec2( tf * 11.0 ), timer ),hash( vec2( tf * 17.0 ), timer ) );
randomVel = randomVel * 2.0 - 1.0;
randomVel.y += 3.0;
randomVel *= fireworksSpeed;
ret[ 0 ] = explode ? vec4( ipos, ctint ) : vec4( pos, tint );
ret[ 1 ] = explode ? vec4( randomVel, 1.0 ) : vec4( vel, fade );
' 4 2 4 0;
10;bury;10;bury;
11;raise;

// Zero exploded sables
0;dup;2;raise;6;totalInstances;instanceVars;0;cat;c''''
ret[ 0 ] = b( ivec4( t.x, 0, 0, 0 ) ) == 0.0 ?
           (t.y < 3 ? -10000.0 : 0.0 ) :
           a( ivec4( t.x, t.y, 0, 0 ) );
' 2 1 0 0;
1;bury;pop;


// place on ground
//print;quit; // instances frame hmap grad highvat lowvat lowinds mat highinds fwpos fwvel sorted
2;dup;1;raise; // instances hmapc frame ...
6;1;dup;shape;c'''
'
int var = t.y;
int ind = t.x;
float x = a( ivec4( ind, 0, 0, 0 ) ) * dim; 
float y = a( ivec4( ind, 2, 0, 0 ) ) * dim; 
ret[ 0 ] = var == 1 ? bf( vec4( y, x, 0.0, 0.0 ) ).x * hscale : a( ivec4( ind, t.y, 0, 0 ) );
' 2 1 0 0;

//print;quit; // instances frame hmap grad highvat lowvat lowinds mat highinds fwpos fwvel
////////////////////////////////////////////////////////////////////
// lod sort
10;bury;10;dup;
0;dup;6;totalInstances;c''''
vec4 pos = vec4( a( ivec4( t.x, 0, 0, 0 ) ), a( ivec4( t.x, 1, 0, 0 ) ), a( ivec4( t.x, 2, 0, 0 ) ), 1.0 );
pos = cat_worldUnrotation*(pos - vec4( cat_origin, 0.0 ) );
pos /= pos.w;
ret[ 0 ] = pos.z < 0.0 ? length( pos.xy )*5.0 - pos.z : 10000.0;
' 1 1 0 0; 14;raise;transferEnd;1;raise;transferStart;14;bury;
////////////////////////////////////////////////////////////////////////////////////////////////
//  THIS IS WHERE WE TRANSFER BACK TO HOST, DO IT ALL IN ONE PLACE!
17;raise;transferEnd;
[0 1 1];s;unext;-9999;1;dup;shape;first;rep;>;sum;live=; // Here we can do things on the cpu with instances
1;dup;transferStart;17;bury;
sort; // first sort
3;dup;6;[1];c''''

float margin = 0.02;
float ox = clamp( cat_origin.x, margin, 1.0 - margin );
float oz = clamp( cat_origin.z, margin, 1.0 - margin );

// Sample heightmap at camera position (note the swizzle from terrain shader)
float terrainHeight = af( vec4( oz * dim, ox * dim, 0.0, 0.0 ) ).x * hscale;

ret[ 0 ] = terrainHeight + 0.02;
' 1 1 0 0;
transferStart;16;bury;15;raise;transferEnd;0;dup;
cat.origin;[1 2 0];s;>;first;ifn'noHeightChange';
cat.origin;[0 1 0];s;1;dup;0;cat;cat.origin;[2 3 0];s;0;cat;cat.origin= 3;
l'noHeightChange';
//print;quit;
pop;
cat.origin;[1 1 1];min;[0 0 0];max;cat.origin= 3;

0;dup;[0 1 0];s;selectedIdx=;
0;dup;2;raise;
1;bury;
//pop;1;bury;pop;

//0;index;1;bury;pop;
6;2;dup;shape;c''''ret[ 0 ] = b( ivec4( int( a( ivec4( t.x, 0, 0, 0 ) ) ), t.y, 0, 0 ) );' 2 1 0 0;1;bury;pop;
//11;dup;selectedIdx;selectedIdx;[1];+;0;cat;[0];0;cat;s;[0 3 1];s;first;selected=;
0;dup;[0 1 0];s;[0 3 1];s;first;
//selected;selectedReticle;-;dt;first;reticleSnappiness;*;3;rep;*;selectedReticle;+;selectedReticle=;
13;raise;6;[3];c''''ret[ 0 ] = mix( a( t ), b( t ), 1.0 - pow( 0.5, dt * reticleSnappiness ) );' 2 1 0 0;12;bury;

totalInstances;instanceVars;*;reshape;
8;bury;







// set light and orthoproject
cat.3dnavParam;set'lrot' 2;
lrot;first;-300;/;[0 1 0];rot; // rot about y
lrot;last;-300;/;[1 0 0];rot;m; // rot about x
0;dup;
set'lightRotation' 16;
0;dup;[0 1];t;
set'lightUnrotation' 16;
[0 0 -1 0];m;unext;[0 3 0];s;[1 -1 1];*;lightDir= 3;
[-0.72 0.72 -0.72 0.72 1.0 5.0];ortho;orthoproj= 16;



//print; quit; // Stack here: prevFrame, heightMap, gradient, highvat, lowvat, lowindices, mat, highindices



/////////////////////////////////////////////////////
// shadow map terrain
1;dup;
// Stack here: heightmapCopy, prevFrame, heightMap, gradient

6;dim;dim;*;first;*;shadowSize;
depth;
c'
const vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out float depth;
'
int index = gl_VertexID / 6;
int x = index / int( dim );
int y = index - x * int( dim );
vec4 v = vec4( float(x), float(y), 0.0, 0.0 ) + verts[ gl_VertexID % 6 ];
v.z = af( v.xy ).x * hscale;
v.xy /= dim;
ret = orthoproj*lightUnrotation*( ( vec4( -hmapCenter, 0.0 ) + v.yzxw ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
depth = ( ret.z / ret.w ) * 0.5 + 0.5;
'
in float depth;
'
ret[ 0 ] = depth;
'
1 1 1 0;
depth;
////////////////////////////////////////////////////////////////////////////
//  Shadow map sables
//   0          1          2          3         4        5       6           7    8
//  shadowmap, prevFrame, heightMap, gradient, highvat, lowvat, lowindices, mat, highindices
depth;backface;
9;dup;7;dup;7;dup;
lowIndexCount;lowInstanceCount;highInstanceCount;sableShadowPass2;
9;dup;9;dup;6;dup;
highIndexCount;highInstanceCount;[0];sableShadowPass2;

depth;backface;texture;








///////////////////////////////////////////////////////////////
// terrain

3;dup;3;dup; // duplicate terrain and heightmap
wdims;0;dup;first;1;dup;last;/;0.5;^;e;set'aspect' 1;pop; // set wdims to window dimensions and aspect.


[90];wdims;0;cat;[0.001 3];0;cat;proj;projm= 16;

// Stack here: the arguments (heightmapcopy, gradientcopy, shadowMap, prevFrame), heightMap, gradient
//2;dup;5;bury;print;   // OOPS dont do this, itll deep copy
2;raise;4;bury;4;dup;2;bury;
depth;backface;
6;dim;dim;*;first;*;wdims;[4];0;cat;
c'
const vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out vec3 color;
out vec3 worldPos;
out vec3 normal;
'
int index = gl_VertexID / 6;
int x = index / int( dim );
int y = index - x * int( dim );
vec4 v = vec4( float(x), float(y), 0.0, 0.0 ) + verts[ gl_VertexID % 6 ];
v.z = af( v.xy ).x * hscale;
vec2 c = vec2( 0.0, ( v.z / hscale ) * ttexsize );
color = bf( c ).rgb;

float leftSample = af( v.xy - vec2( 1.0, 0.0 ) ).x * hscale;
float rightSample = af( v.xy + vec2( 1.0, 0.0 ) ).x * hscale;
vec3 nrml1 = vec3( 2.0 / dim, 0.0, leftSample - rightSample );
float upSample = af( v.xy - vec2( 0.0, 1.0 ) ).x * hscale;
float downSample = af( v.xy + vec2( 0.0, 1.0 ) ).x * hscale;
vec3 nrml2 = vec3( 0.0, 2.0 / dim, upSample - downSample );
normal = normalize( cross( nrml1, nrml2 ) ).yzx;


v.xy /= dim;
worldPos = v.yzx;
ret = projm*cat_worldUnrotation*( v.yzxw - vec4( cat_origin, 0.0 ) );
'
in vec3 color;
in vec3 worldPos;
in vec3 normal;
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
vec3 d = worldPos - cat_origin;
vec4 lightPos = orthoproj*lightUnrotation*( vec4( -hmapCenter, 0.0 ) + vec4( worldPos, 1.0 ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
lightPos /= lightPos.w;
lightPos.xyz = lightPos.xyz * 0.5 + 0.5;
float curDepth = lightPos.z;
float centerLightDepth = cf( lightPos.xy * shadowSize.xy ).x;
float spread = clamp( ( curDepth - centerLightDepth ) * softShadows, 1.0, 100000000.0 );


float shadow = 0.0;
for( float dx = -0.5; dx <= 0.5; ++dx ){
  for( float dy = -0.5; dy <= 0.5; ++dy ){
    vec2 jitter = vec2( hash( vec2( dx, dy ), timer ), hash( vec2( dx + 10.0, dy ), timer ) ) - 0.5;
    vec2 delta = ( vec2( dx, dy ) + jitter ) * spread;

    float lightDepth = cf( lightPos.xy * shadowSize.xy + delta ).x;
    shadow += ( curDepth - shadowBias ) > lightDepth ? 1.0 : 0.0;
  }
}
shadow /= 4.0;
shadow *= 0.5;


float len = length( d );
float t = ( waterLevel - cat_origin.y ) / d.y;
if( d.y > 0.0 )
  t = 1.0;
float waterDepth = len * ( 1.0 - t );
float fog = clamp( waterDepth * waterFogScale, 0.0, 1.0 );
float diffuse = dot( normal, lightDir ) * 0.5 + 0.5;
diffuse *= ( 1.0 - shadow );
ret[ 0 ] = vec4( mix( diffuse * color, vec3( 0.0, 0.1, 0.3 ), fog ), 1.0 );
'
3 1 400 0;
1;raise;pop;



/////////////////////////////////
//sky
6;1;dup;shape;c''''
vec3 ray = normalize(
    vec3(
      ( tf.xy / wdims * 2.0 - 1.0 ) * vec2(aspect, 1.0/aspect), 
      -1.0
    )
);
ray = ( cat_worldRotation * vec4( ray, 1.0 ) ).xyz;
float skyness = clamp( dot( ray, vec3( 0.0, 1.0, 0.0 ) ) * 5.0 + 2.3, 0.0, 1.0 );
vec3 skyColor = mix( vec3( 0.3, 0.1, 0.5 ),
                     vec3( 0.1, 0.2, 0.9 ),
                     clamp( dot( lightDir, vec3( 0.0, 1.0, 0.0 ) ), 0.0, 1.0 ) );
float sunness = clamp( dot( lightDir * vec3( -1.0, 1.0, -1.0 ), ray ) * 80.0 - 78.0, 0.0, 1.0 );
skyColor = mix( skyColor, vec3( 1.0, 1.0, 0.3 ), sunness );
ret[ 0 ] = vec4( skyColor * skyness, 1.0 );
' 0 1 400 1;
depth;backface;



//////////////////////////////////////////////////////////////////////
// Selected ui
13;dup;
3;2;dup;shape;c'
const vec4 verts[3] = vec4[](
    vec4( 0.0,        2.0, 0.0, 1.0),   // top
    vec4(-1.732051, -1.0, 0.0, 1.0),   // bottom left  (-v3)
    vec4( 1.732051, -1.0, 0.0, 1.0)    // bottom right (v3)
);
mat3 rotY(float facing) {
    float c = cos(facing);
    float s = sin(facing);
    return mat3(
        c,   0.0,  s,
        0.0, 1.0,  0.0,
       -s,   0.0,  c
    );
}
out vec2 tripos;
flat out float radius;
'
vec4 pos = vec4( verts[ gl_VertexID ].xzy * rotY( jobFacing / 360.0 ), 1.0 );
tripos = verts[ gl_VertexID ].xy;
pos.xyz *= sableScale;
pos.xyz += vec3( a( ivec4( 0, 0, 0, 0 ) ), a( ivec4( 1, 0, 0, 0 ) ), a( ivec4( 2, 0, 0, 0 ) ) );
radius = mod( timer * 5.0, 2.0 );
ret = projm*cat_worldUnrotation*( pos - vec4( cat_origin, 0.0 ) );
'
in vec2 tripos;
flat in float radius;
'
ret[ 0 ] = vec4( 0.0, 1.0, 1.0, 1.0 );
if( tripos.x > -0.15 && tripos.x < 0.15 && tripos.y > 0.0 )
  ret[ 0 ] = vec4( 1.0, 0.0, 0.0, 1.0 );
else if( length( tripos ) > radius + 0.2 || length( tripos ) < radius - 0.2 )
  discard;
' 1 1 400 1;
//////////////////////////////////////////////////
// sables
//print; quit; // frame hmap smap grad highvat lowvat lowindices mat highindices
7;dup;7;dup;7;dup;5;dup;3;bury; // lowvatc lowindsc matc smapc frame hmap smap grad highvat lowvat lowindices mat highindices instances fwpos fwvel sorted


depth;backface;
13;dup;
lowIndexCount;lowInstanceCount;highInstanceCount;sablePass2;
2;raise;      // smap frame hmap grad highvat lowvat lowinds mat highinds
7;dup;9;dup;6;dup;12;dup;
//print;quit; // sortedc instancesc highvatc highindsc matc smap frame hmap grad highvat lowvat lowinds mat highinds instances fwpos fwvel sorted  
highIndexCount;highInstanceCount;[0];sablePass2;
depth;backface;



////////////////////////////////////////////////
// fireworks pass
// 0     1    2    3       4      5       6   7        8         9     10
// frame hmap grad highvat lowvat lowinds mat highinds instances fwpos fwvel
10;dup;10;dup; // fwposcopy fwvelcopy ...
0;dup;shape;0;dup;[0 1 0];s;1;raise;[1 2 0];s;*;[3];*;unext;wdims;[4];0;cat;depth;c'
const vec4 verts[3] = vec4[](
    vec4( 0.0,        2.0, 0.0, 1.0),   // top
    vec4(-1.732051, -1.0, 0.0, 1.0),   // bottom left  (-v3)
    vec4( 1.732051, -1.0, 0.0, 1.0)    // bottom right (v3)
);
out vec2 tripos;
out float tint;
out float fade;
'
int vert = gl_VertexID % 3;
int idx = gl_VertexID / 3;
float instance = float( idx % int( fireworksDims.x ) );
float firework = float( idx / int( fireworksDims.x ) ); 
vec4 posSamp = af( vec4( instance, firework, 0.0, 0.0 ) );
vec4 velSamp = bf( vec4( instance, firework, 0.0, 0.0 ) );
vec4 pos = vec4( posSamp.xyz, 1.0 );
tint = posSamp.w;
fade = velSamp.w;
tripos = verts[ vert ].xy;
ret = projm*cat_worldUnrotation*( pos - vec4( cat_origin, 0.0 ) );
ret.xy += tripos * fireworkSize * vec2( 1.0 / aspect, aspect );
'
vec3 hue2rgb(float h) {
    vec3 p = abs(fract(h + vec3(0.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return clamp(p - 1.0, 0.0, 1.0);
}
in vec2 tripos;
in float tint;
in float fade;
'
if( length( tripos ) > 1.0 )
  discard;
ret[ 0 ] = vec4( hue2rgb( tint ), 0.0 );
' 2 1 400 1;depth;

//////////////////////////////////////////////////////////////////
// UI
// frame hmap grad highvat lowvat lowinds mat highinds instances fwpos fwvel
// 0     1    2    3       4      5       6   7        8         9     10
0;dup;6;uiDims;[4];0;cat;c'
const vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
'
vec2 pos = verts[ gl_VertexID ].xy;
ret = vec4( pos * 2.0 - 1.0, 0.0, 1.0 );
''ret[0] = af( vec4( tf.x + ( wdims.x - uiDims.x ) / 2.0, tf.y, 0.0, 0.0 ) );' 1 1 400 0;texture;
16;dup;1;bury;
6;wdims;[4];0;cat;c'
const vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out vec2 pos;
'
pos = verts[ gl_VertexID ].xy;
ret = vec4( ( uiDims.x / wdims.x ) * ( pos.x * 2.0 - 1.0 ),
            ( uiDims.y / wdims.y ) * pos.y * 2.0 - 1.0, 0.0, 1.0 );
'
in vec2 pos;
'
float l = 3.5;
vec2 uv = pos * uiDims;

vec2 d = vec2( 1.4 ); 
vec2 fpos = vec2( fract( pos.x * numJobs ), pos.y * 2.0 );
int which = int( pos.x * numJobs );

vec4 acc;
if( which != int( numJobs ) - 1 ){
  acc = af(vec4(uv, 0.0, l)) * 0.38;

  acc += af(vec4(uv + d, 0.0, l)) * 0.155;
  acc += af(vec4(uv - d, 0.0, l)) * 0.155;
  acc += af(vec4(uv + vec2(d.x, -d.y), 0.0, l)) * 0.155;
  acc += af(vec4(uv + vec2(-d.x, d.y), 0.0, l)) * 0.155;
} else
  acc = bf( vec4( fpos * 512.0, 0.0, 0.0 ) );

if( which == int( numJobs ) - 2 ){
  vec4 catbox = bf( vec4( fpos * 512.0 + vec2( 640.0, -100.0 ), 0.0, 0.0 ) );
  acc = mix( acc, catbox, catbox.a );
}


vec2 p = fpos * 2.0 - 1.0 - vec2( 0.0, 1.0 );
vec2 ap = abs(p);
if( abs( ap.y ) > 0.5 )
  ap.y -= 1.0;

// Edge lines
float edge = max(ap.x, ap.y);
float line = smoothstep(0.9, 0.91, edge) - smoothstep(0.91, 0.95, edge);

// Corner brackets (only show near corners)
float corner = step(0.7, ap.x) * step(0.7, ap.y);
float bracket = corner * line * 2.0;

// Subtle vignette
float vignette = 1.0 - smoothstep(0.5, 2.1, length(p));
float mult = ( which == int( activeJob ) ? 1.0 : 0.5 );
vec3 frameColor = ( which == int( activeJob ) ? vec3( 1.0, 0.0, 0.0 ) : vec3(0.0, 1.0, 1.0) ) * (line * 0.3 + bracket);
if( which == int( numJobs ) - 1 ){
  if( nukeBar >= 2.0 )
    ret[ 0 ] = vec4( acc.rgb + frameColor, 1.0 );
  else if( nukeBar < pos.y )
    ret[ 0 ] = vec4( acc.rgb * 0.5 * vignette + frameColor, 1.0 );
  else
    ret[ 0 ] = mix( vec4( acc.rgb * 0.5 * vignette + frameColor, 1.0 ), vec4( 1.0, 0.0, 0.0, 1.0 ), 0.5 );
} else
  ret[0] = vec4( acc.rgb * mult * vignette + frameColor, 1.0 );


' 2 1 400 1;
8;raise;pop;
10;raise;totalInstances;instanceVars;*;reshape;8;bury;




/////////////////////////////////////////////////////////
// Sables on ui
// frame hmap grad highvat lowvat lowinds mat highinds instances fwpos fwvel reticle sorted height uitex
// 0     1    2    3       4      5       6   7        8         9     10    11      12     13     14

100000; // shadow frame ...
7;dup; // mat shadow frame ....
9;dup; // highinds mat shadow frame ...
6;dup; // highvat highinds mat shadow frame ...
aspect;[1];0;cat;atan;114.59155902616464175359630962821;*;e;fovm=;
'';
[0];ic=;
l'jobloop';
ic;
[0.5];+;numJobs;/;[2];*;[1];-;uiDims;[0 1 0];s;*;wdims;[0 1 0];s;/;
//ndc.x = ((i + 0.5) / numJobs * 2 - 1) * (uiDims.x / wdims.x)
[1];+;[2];/;ndcx=;[0];
//worldPos.x = ndc.x * 0.1 * aspect / fov
[0];//[-0.87];[0.1];*;
0;cat; // y
[-0.1]; // z
[17.08];0;cat; // facing
ic;[1];uiSize;-;[0.38];uiSize;*;+;[1023];*;floor;[1024];*;ndcx;[1023];*;floor;+;[1048576];/;+; //animidx
0;cat;0;cat; 
[1];ic;activeJob;==;-;timer;*;0;cat; // animStart
ic;numJobs;/;[1];ic;activeJob;==;-;[127];*;+;0;cat;0;cat; // hue
ic;[1];+;ic=;
ic;numJobs;-;[2];+;first;ifn'jobloop';

2;dup;shape; // indexCount instances highvat highinds mat shadow frame ...
numJobs;[2];-;[0]; // offset instanceCount indexCount instances highvat highinds mat shadow frame ...
projm;oldproj=;
fovm;wdims;0;cat;[0.001 0.2];0;cat;proj;projm= 16;
cat.origin;oldorigin=;
cat.worldUnrotation;oldrot=;
lightDir;oldlightdir=;
[0.5 1 -1.5];lightDir= 3;
[0 0 0];cat.origin= 3;
[[1 0 0 0]
 [0 1 0 0]
 [0 0 1 0]
 [0 0 0 1]];cat.worldUnrotation= 16;
sableScale;oldsableScale=;
[0.075];uiSize;*;sableScale= 1;

depth;backface;
sablePass2;
//  Sable pass2, expects bypassCount instanceCount indexCount instances vat indices mat smap frame
depth;backface;

oldsableScale;sableScale= 1;
oldproj;projm= 16;
oldlightdir;lightDir= 3;
oldrot;cat.worldUnrotation= 16;
oldorigin;cat.origin= 3;



///////////////////////////////////////////////////////////
// UI text
[1 2 20 33];live;e;0;cat;jobNums=;
[0];i=;
l'jobNumsLoop';
jobNums;i;i;[1];+;0;cat;[0];0;cat;s;
first;toString 0;'0';first;[4];2;dup;shape;-;first;rep;1;bury;0;cat;
e;
i;first;ifn'nocat';
0;cat;
l'nocat';
i;[1];+;i=;
numJobs;i;-;first;if'jobNumsLoop';
[0 0 24 8];1;3;rep;numJobs;0;cat;*;[0 0 1 1];+;
cat.textAreaToFlatTexture;

6;numJobs;first;*;2;dup;shape;additive;c'
const vec4 verts[] = vec4[](
vec4( 0.0,0.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ), 
vec4( 0.0,1.0,0.0,1.0 ), 
vec4( 1.0,1.0,0.0,1.0 ),
vec4( 0.0,1.0,0.0,1.0 ),
vec4( 1.0,0.0,0.0,1.0 ) 
);
out vec2 uv;
flat out float which;
'
which = floor( float( gl_VertexID ) / 6.0 );
vec2 uitd = vec2( 6.0, 8.0 ) * ( which == 0.0 ? vec2( 3.0, numJobs ) : vec2( 2.0, numJobs ) ) + vec2( 1.0, 1.0 );
int vert = gl_VertexID % 6;
ret.xyz = ( verts[ vert ].xyz * 2.0 - 1.0 ) * uiSize * vec3( 0.115, 0.115, 1.0 );
ret.x /= aspect * aspect;
ret.x *= uitd.x / ( ( uitd.y - 1.0 ) / numJobs + 1.0 );
//ret.x += ( ( uiDims.x - wdims.x ) * 0.5 / wdims.x );
ret.x -= -( uiDims.x / wdims.x ) + ( uiDims.x / numJobs ) * ( which * 2.0 + 1.0 ) / wdims.x;
ret.y += -1.0 + ( uiDims.y / wdims.y ) * 0.26;
ret.w = 1.0;
uv = verts[ vert ].xy * ( ( uitd - vec2( 0.0, 1.0 ) ) * vec2( 1.0, 1.0 / numJobs ) + vec2( 0.0, 1.0 ) );
'
flat in float which;
in vec2 uv;
'
float val = 1.0 - af( uv + vec2( 0.0, 8.0 ) * which + vec2( 6.0, 0.0 ) * ( which == 0.0 ? 1.0 : 2.0 ) );
ret[ 0 ] = vec4( vec3( val ), 1.0 );
' 1 1 400 1;additive;







//////////////////////////////////////////////////////////////////
// Help and framerate
cat.keyState;[226 227 0];s;cat.keyState;[230 231 0];s;+;cat.keyPresses;[40 41 0];s;*;unext;ifn'nofullscreen';
fullscreen;
l'nofullscreen';
cat.keyState;[58 59 0];s;first;ifn'skipf1';
'Click and drag: rotate view                     ';e;
'Right click: fly forward                        ';e;0;cat;
'w/s/a/d/c/shift/ctrl/space/q/e: fly around      ';e;0;cat;
'Mouse wheel: change fly speed                   ';e;0;cat;
'Hold f key and drag mouse: change light location';e;0;cat;
'Enter: catgirl fireworks :D                     ';e;0;cat;
'R: reset                                        ';e;0;cat;
cat.textToTexture;cat.blitText;
l'skipf1';
cat.keyState;[59 60 0];s;first;cat.gamepadState;[13 14 0];s;first;+;ifn'skipf2';
'FPS:';1;timeDelta;/;toString;0;cat;' Hours:';0;cat;time;first;toString;0;cat;' Seconds:';0;cat;time;last;toString;0;cat;e;
cat.textToTexture;cat.blitText;
l'skipf2';

////////////////////////////////////////////
// Game Over
live;if'decreaseGameover';
gameover;dt;gameoverTime;/;+;gameover= 1;
gameover;[1];-;first;ifn'gameoverDone';
8;raise;pop;resetInstances;8;bury;
1;if'gameoverDone';
l'decreaseGameover';
gameover;first;ifn'gameoverDone';
gameover;dt;gameoverTime;/;-;gameover= 1;
l'gameoverDone';


gameover;first;ifn'noGameoverFade';
6;1;dup;shape;c''''ret[ 0 ] = af( vec4( tf, 0.0, 0.0 ) ) * ( 1.0 - gameover );' 1 1 400 0;
l'noGameoverFade';

// generate mipmaps for ssaa
ssaa;first;1;-;ifn'nomipmap';
texture;
l'nomipmap';

// Functions
1;if'skipFuncs';
////////////////////////////////////////////////////////////////////
// bake VAT  takes vertex data and bone matrices and produces a VAT
// stack should be a) bones and b) vertex data.
l'bakeVat';
6;2;dup;shape;[0 1 0];s;frameCount;animCount;[2];*;*;0;cat;[4];0;cat;
c'''
mat4 getBoneMat(int frame, int bone, int anim) {
    mat4 m;
    for (int col = 0; col < 4; col++) {
       vec4 val = af(vec4(
           float(col) + 0.5,
           float(anim) + animCount * float(bone) + 0.5,
           float(frame), 0.0
       ));
       m[col] = val;
    }
    return m;
}
'
int vertIdx = int(tf.x);
int frameAnim = int(tf.y) / 2;
int posOrNormal = int(tf.y) % 2;
int frame = frameAnim % int(frameCount);
int anim = frameAnim / int(frameCount);

vec4 v = vec4(
    b(ivec4(vertIdx, 0, 0, 0)),
    b(ivec4(vertIdx, 1, 0, 0)),
    b(ivec4(vertIdx, 2, 0, 0)),
    1.0
);

ivec4 bi = ivec4(
    b(ivec4(vertIdx, 8, 0, 0)),
    b(ivec4(vertIdx, 9, 0, 0)),
    b(ivec4(vertIdx, 10, 0, 0)),
    b(ivec4(vertIdx, 11, 0, 0))
);
vec4 weights = vec4(
    b(ivec4(vertIdx, 12, 0, 0)),
    b(ivec4(vertIdx, 13, 0, 0)),
    b(ivec4(vertIdx, 14, 0, 0)),
    b(ivec4(vertIdx, 15, 0, 0))
);
vec2 uv = vec2( b( ivec4( vertIdx, 6, 0, 0 ) ), b( ivec4( vertIdx, 7, 0, 0 ) ) );
vec4 normal = vec4( b( ivec4( vertIdx, 3, 0, 0 ) ), b( ivec4( vertIdx, 4, 0, 0 ) ),
                    b( ivec4( vertIdx, 5, 0, 0 ) ), 1.0 );
mat4 skin = getBoneMat(frame, bi.x, anim) * weights.x +
            getBoneMat(frame, bi.y, anim) * weights.y +
            getBoneMat(frame, bi.z, anim) * weights.z +
            getBoneMat(frame, bi.w, anim) * weights.w;

v = skin * v;
v.w = uv.x;
normal = skin * normal;
normal.w = uv.y;
ret[0] = posOrNormal == 0 ? v : normal;
' 2 1 400 0;
return;






//////////////////////////////////////////////////////////////////////////
// sable shadow pass 2,
// expects from top to bottom bypasscount, instancecount, indexcount, vat, indices, instances

l'sableShadowPass2';
bypass= 1;
instanceCount= 1;indexCount= 1;
indexCount;unext;instanceCount;unext;*;
shadowSize;
c'
mat3 rotY(float facing) {
    float c = cos(facing);
    float s = sin(facing);
    return mat3(
        c,   0.0,  s,
        0.0, 1.0,  0.0,
       -s,   0.0,  c
    );
}
out float depth;
'
int vertsPerInstance = int(indexCount);
int instanceID = gl_VertexID / vertsPerInstance + int(bypass);
int localVertID = gl_VertexID % vertsPerInstance;
int index = int( b( ivec4( localVertID, 0, 0, 0 ) ) );
float xCoord = float(index) + 0.5;

int base = instanceID * int(instanceVars);
 vec3 instPos = vec3(
     c(ivec4(base + 0, 0, 0, 0)),
     c(ivec4(base + 1, 0, 0, 0)),
     c(ivec4(base + 2, 0, 0, 0))
 );
 float facing = c(ivec4(base + 3, 0, 0, 0));
 float animIdx = c(ivec4(base + 4, 0, 0, 0));
 float animStart = c(ivec4(base + 5, 0, 0, 0));
int anim = int( animIdx );
float pframe = clamp( timer - animStart, 0.0, 10000000000000000.0 );
float frame = mod(pframe * 24.0, frameCount);
int f0 = int( frame );
int f1 = ( f0 + 1 ) % int( frameCount );
float lerp = fract( frame );

int frameAnim0 = f0 + anim * int(frameCount);
int frameAnim1 = f1 + anim * int(frameCount);
float yPos0 = float(frameAnim0 * 2) + 0.5;
float yPos1 = float(frameAnim1 * 2) + 0.5;
vec4 v0 = af( vec4(xCoord, yPos0, 0.0, 0.0 ) );
vec4 v1 = af( vec4(xCoord, yPos1, 0.0, 0.0 ) );
vec4 v = v1 * lerp + v0 * ( 1.0 - lerp );

v.w = 1.0;
v.xyz = rotY( facing * 3.1415926535897932384626433832795 * 2.0 ) * v.xyz;
v.xyz *= sableScale;
v.xyz += instPos;

ret = orthoproj*lightUnrotation*( ( vec4( -hmapCenter, 0.0 ) + v ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
depth = ( ret.z / ret.w ) * 0.5 + 0.5;
'
in float depth;
'
ret[ 0 ] = depth;
' 3 1 1 1;
return;











///////////////////////////////////////////////////////////
//  Sable pass2, expects bypassCount instanceCount indexCount instances vat indices mat smap frame
l'sablePass2';
bypass= 1;
instanceCount= 1;indexCount= 1;
indexCount;unext;instanceCount;unext;*;
6;dup;shape;
c'
out vec3 normal;
out vec2 uv;
out vec3 worldPos;
flat out float mat;
flat out vec3 tint;
flat out float job;
flat out float fade;
vec3 hue2rgb(float h) {
    vec3 p = abs(fract(h + vec3(0.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return clamp(p - 1.0, 0.0, 1.0);
}
mat3 rotY(float facing) {
    float c = cos(facing);
    float s = sin(facing);
    return mat3(
        c,   0.0,  s,
        0.0, 1.0,  0.0,
       -s,   0.0,  c
    );
}
'
mat = 0.0;
int vertsPerInstance = int(indexCount);
int instanceID = int( bypass ) + gl_VertexID / vertsPerInstance;
int localVertID = gl_VertexID % vertsPerInstance;
int index = int( c( ivec4( localVertID, 0, 0, 0 ) ) );
float xCoord = float(index) + 0.5;

int base = instanceID * int(instanceVars);
 vec3 instPos = vec3(
     a(ivec4(base + 0, 0, 0, 0)),
     a(ivec4(base + 1, 0, 0, 0)),
     a(ivec4(base + 2, 0, 0, 0))
 );
float rawfacing = a(ivec4(base + 3, 0, 0, 0));
float facing = fract( rawfacing );
float backup = floor( rawfacing ) / 100.0;
float idxRaw = a(ivec4(base + 4, 0, 0, 0));
float twovars = fract( idxRaw ) * 1048576.0;
float movey = floor( twovars / 1024.0 ) / 1023.0;
float movex = mod( twovars, 1024.0 ) / 1023.0;
movex = movex * 2.0 - 1.0;
float animIdx = floor( idxRaw );
float animStart = a(ivec4(base + 5, 0, 0, 0));
float rawtint = a(ivec4(base + 6, 0, 0, 0));
tint = hue2rgb( fract( rawtint ) );
fade = floor( rawtint ) / 255.0;
int anim = int( animIdx );
job = animIdx;
float pframe = clamp( timer - animStart, 0.0, 10000000000000000.0 );
float frame = mod(pframe * 24.0, frameCount);
int f0 = int( frame );
int f1 = ( f0 + 1 ) % int( frameCount );
float lerp = fract( frame );

int frameAnim0 = f0 + anim * int(frameCount);
int frameAnim1 = f1 + anim * int(frameCount);
float yPos0 = float(frameAnim0 * 2) + 0.5;
float yPos1 = float(frameAnim1 * 2) + 0.5;
float yNrm0 = float(frameAnim0 * 2 + 1) + 0.5;
float yNrm1 = float(frameAnim1 * 2 + 1) + 0.5;
vec4 v0 = bf( vec4(xCoord, yPos0, 0.0, 0.0 ) );
vec4 v1 = bf( vec4(xCoord, yPos1, 0.0, 0.0 ) );
vec4 n0 = bf( vec4(xCoord, yNrm0, 0.0, 0.0 ) );
vec4 n1 = bf( vec4(xCoord, yNrm1, 0.0, 0.0 ) );
vec4 n = n1 * lerp + n0 * ( 1.0 - lerp );
vec4 v = v1 * lerp + v0 * ( 1.0 - lerp );

uv = vec2( v.w, n.w );
v.w = 1.0;
n.w = 1.0;
n.xyz = rotY( facing * 3.1415926535897932384626433832795 * 2.0 ) * n.xyz;
normal = normalize( n.xyz );
v.xyz = rotY( facing * 3.1415926535897932384626433832795 * 2.0 ) * v.xyz;
v.xyz *= sableScale;
v.xyz += instPos;
worldPos = v.xyz;
ret = projm*cat_worldUnrotation*( v - vec4( cat_origin, 0.0 ) );
ret.z -= backup;
ret.y -= movey * ret.w;
ret.x += movex * ret.w;
'
in vec3 normal;
in vec2 uv;
in vec3 worldPos;
flat in vec3 tint;
flat in float mat;
flat in float job;
flat in float fade;

float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
vec2 muv = fract( uv );

vec4 color = df( vec3( muv * atlasSize, mat * 2.0 ) );
if( color.a > 0.99 && color.a < 1.0 )
   color.rgb = tint;
else if( color.a > 0.95 && color.a <= 0.99 ){
  int h = int( 98.0 - floor( color.a * 100.0 ) );
  const float uvh[ 3 ] = float[]( 1.0, 0.0, 2.0 );
  vec2 uv = vec2( 4.0 + 8.0 * job, matDim.y - ( 4.0 + 8.0 * uvh[ h ] ) );
  color.rgb = df( vec4( uv, 0.0, 0.0 ) ).rgb;
}
// else if( color.a > 0.98 && color.a <= 0.99 )
//   color.rgb = df( vec4( 4.0 + 8.0 * job, matDim.y - 12.0, 0.0, 0.0 ) ).rgb;
// else if( color.a > 0.97 && color.a <= 0.98 )
//   color.rgb = df( vec4( 4.0 + 8.0 * job, matDim.y - 4.0, 0.0, 0.0 ) ).rgb;
// else if( color.a > 0.96 && color.a <= 0.97 )
//   color.rgb = df( vec4( 4.0 + 8.0 * job, matDim.y - 20.0, 0.0, 0.0 ) ).rgb;
//if( color.a < 0.5 )  discard;


// // Combine
vec3 diffuse = color.rgb;
vec3 L = normalize(lightDir * vec3(-1.0, 1.0, -1.0));


vec4 lightPos = orthoproj*lightUnrotation*( vec4( -hmapCenter, 0.0 ) + vec4( worldPos, 1.0 ) ) + vec4( 0.0, 0.0, 1.0, 0.0 );
lightPos /= lightPos.w;
lightPos.xyz = lightPos.xyz * 0.5 + 0.5;
float curDepth = lightPos.z;

float shadow = 0.0;
for( float dx = -0.5; dx <= 0.5; ++dx ){
  for( float dy = -0.5; dy <= 0.5; ++dy ){
    vec2 jitter = vec2( hash( vec2( dx, dy ), timer ), hash( vec2( dx + 10.0, dy ), timer ) ) - 0.5;
    vec2 delta = ( vec2( dx, dy ) + jitter ) * 1.0; // no spread calc needed for small objects
    float lightDepth = ef( lightPos.xy * shadowSize.xy + delta ).x;
    shadow += ( curDepth - shadowBias ) > lightDepth ? 1.0 : 0.0;
  }
}
shadow = shadow / 4.0 * 0.5;
float ambient = 0.3;
ret[ 0 ] = ( 1.0 - fade ) * vec4( diffuse * clamp( dot( normal, L ) + ambient, 0.0, 1.0 ) * (1.0 - shadow), 1.0 );
// //ret[0] = vec4(vec3(roughness), 1.0);
// //ret[ 0 ] = vec4( clamp( dot( finalNormal, lightDir * vec3( -1.0, 1.0, -1.0 ) ), 0.2, 1.0 ) * color.rgb , 1.0 );
// //ret[ 0 ] = vec4( uv.x, uv.y, 0.0, 1.0 );
// ret[ 0 ] = vec4( color );
' 5 1 400 1;

return;


















l'resetInstances';
6;totalInstances;instanceVars;*;
c'''
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
int instance = t.x / int( instanceVars );
int var = t.x % int( instanceVars );
ret[ 0 ] = var == 4 ? floor( hash( vec2( t.xy ), timer ) * 1.999 ) + 512.0 / 1048576.0: hash( vec2( t.xy ), timer );
' 0 1 0 0;
reset;
return;



l'explodify';
6;totalInstances;instanceVars;*;
c'''
float hash( vec2 p, float time ){
    float h = dot( p, vec2( 127.1, 311.7 ) ) / 1000.0 + fract( time * 1.2123438709 );
    return fract( sin( h ) * 43758.5453123 );
}
'
int instance = t.x / int( instanceVars );
int var = t.x % int( instanceVars );
ret[ 0 ] = var == 4 ? 2.0 + 512.0 / 1048576.0 : a( ivec4( t.x, 0, 0, 0 ) );
ret[ 0 ] = var == 5 ? timer + 1.0 + hash( vec2( t.x, timer ), timer ) * 10.0 : ret[ 0 ];
' 1 1 0 0;
return;




l'skipFuncs';
